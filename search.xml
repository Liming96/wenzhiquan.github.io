<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式--观察者模式]]></title>
    <url>%2F2018%2F06%2F26%2F2018-06-26-design-pattern-observer%2F</url>
    <content type="text"><![CDATA[“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。” 1. 简介当对象间存在一对多关系，且当一个对象被修改时，会自动通知它的依赖对象，则使用观察者模式（Observer Pattern）。观察者模式属于行为型模式。 2. 模式意图可以建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为被观察者，而被通知的对象称为观察者，一个被观察者可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式意图。 3. 优缺点 优点 观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有不同的表示层作为具体观察者角色。 观察者模式在被观察者和观察者之间建立一个抽象的耦合。 观察者模式支持广播通信。 观察者模式符合“开闭原则”的要求。 缺点 如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道被观察者发生了变化。 4. 模式结构抽象工厂模式包含如下角色： Subject：目标 ConcreteSubject：具体目标 Observer：观察者 ConcreteObserver：具体观察者 5. 实现Subject: 12345public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver();&#125; ConcreteSubject: 12345678910111213141516171819202122232425262728293031323334353637public class ConcreteSubject implements Subject &#123; private ArrayList&lt;Observer&gt; observers; private Object data; public ConcreteSubject() &#123; this.observers = new ArrayList&lt;&gt;(); &#125; @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int index = observers.indexOf(o); if (index &gt;= 0) &#123; observers.remove(index); &#125; &#125; @Override public void notifyObserver() &#123; for (Observer observer: observers) &#123; observer.update(this, data); &#125; &#125; public void dataChanged() &#123; notifyObserver(); &#125; public void setData(Object data) &#123; this.data = data; dataChanged(); &#125;&#125; Observer: 123public interface Observer &#123; public void update(Subject sub, Object obj);&#125; ConcreteObserver: 12345678910111213public class ConcreteObserver implements Observer&#123; private Subject concreteSubject; public ConcreteObserver(Subject subject) &#123; this.concreteSubject = subject; this.concreteSubject.registerObserver(this); &#125; @Override public void update(Subject sub, Object obj) &#123; System.out.println("Subject is " + sub.toString() + " Data is " + obj.toString()); &#125;&#125; Main: 123456789public class Main &#123; public static void main(String[] args) &#123; ConcreteSubject subject = new ConcreteSubject(); Observer observer = new ConcreteObserver(subject); subject.setData(new HashMap&lt;Integer, Integer&gt;()&#123;&#123;put(1, 1);&#125;&#125;); subject.setData(new HashMap&lt;Integer, Integer&gt;()&#123;&#123;put(2, 2);&#125;&#125;); subject.setData(new HashMap&lt;Integer, Integer&gt;()&#123;&#123;put(3, 3);&#125;&#125;); &#125;&#125; 输出结果： 123Subject is observer_pattern.ConcreteSubject@610455d6 Data is &#123;1=1&#125;Subject is observer_pattern.ConcreteSubject@610455d6 Data is &#123;2=2&#125;Subject is observer_pattern.ConcreteSubject@610455d6 Data is &#123;3=3&#125; 6. 使用场景在以下情况下可以使用观察者模式： 一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--抽象工厂模式]]></title>
    <url>%2F2018%2F06%2F25%2F2018-06-25-design-pattern-abstract-factory%2F</url>
    <content type="text"><![CDATA[“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。” 1. 简介在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。此时工厂方法模式就无法完成需求，而抽象工厂模式可以解决这个问题。 2. 模式意图当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式与工厂方法模式最大的区别在于: 工厂方法模式针对的是一个产品等级结构 抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。 当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 3. 优缺点 优点 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 缺点 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 4. 模式结构抽象工厂模式包含如下角色： AbstractFactory：抽象工厂 ConcreteFactory：具体工厂 AbstractProduct：抽象产品 Product：具体产品 时序图 5. 实现AbstractProductA: 123public interface AbstractProductA &#123; void display();&#125; AbstractProductB: 123public interface AbstractProductB &#123; void draw();&#125; ProductA1: 123456public class ProductA1 implements AbstractProductA &#123; @Override public void display() &#123; System.out.println("This is product A1"); &#125;&#125; ProductA2: 123456public class ProductA2 implements AbstractProductA &#123; @Override public void display() &#123; System.out.println("This is product A2"); &#125;&#125; ProductB1: 123456public class ProductB1 implements AbstractProductB &#123; @Override public void display() &#123; System.out.println("This is product B1"); &#125;&#125; ProductB2: 123456public class ProductB2 implements AbstractProductB &#123; @Override public void display() &#123; System.out.println("This is product B2"); &#125;&#125; AbstractFactory: 1234public abstract class AbstractFactory &#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125; ConcreteFactory1: 1234567891011public class ConcreateFactory1 extends AbstractFactory&#123; @Override public ProductA1 createProductA() &#123; return new ProductA1(); &#125; @Override public ProductB1 createProductB() &#123; return new ProductB1(); &#125;&#125; ConcreteFactory1: 1234567891011public class ConcreateFactory2 extends AbstractFactory&#123; @Override public ProductA2 createProductA() &#123; return new ProductA2(); &#125; @Override public ProductB2 createProductB() &#123; return new ProductB2(); &#125;&#125; Main: 1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args) &#123; AbstractFactory productFactory1 = new ConcreateFactory1(); AbstractProductA a1 = productFactory1.createProductA(); a1.display(); AbstractProductB b1 = productFactory1.createProductB(); b1.draw(); AbstractFactory productFactory2 = new ConcreateFactory2(); AbstractProductA a2 = productFactory2.createProductA(); a2.display(); AbstractProductB b2 = productFactory2.createProductB(); b2.draw(); &#125;&#125; 输出结果： 1234This is product A1This is product B1This is product A2This is product B2 6. 使用场景在以下情况下可以使用抽象工厂模式： 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。系统中有多于一个的产品族，而每次只使用其中某一产品族。 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--工厂方法模式]]></title>
    <url>%2F2018%2F06%2F16%2F2018-06-16-design-pattern-factory-method%2F</url>
    <content type="text"><![CDATA[“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。” 1. 简介由于简单工厂模式每次增加新的产品时，都需要修改工厂类，违背了开闭原则，可以通过定义工厂类的父类，为每种产品都创建一个工厂，从而动态的获取子类，并且增加产品时增加工厂子类即可，不用修改工厂父类。 2. 目的解决简单工厂模式中违背开闭原则的问题 3. 优缺点 优点 新增产品时，增加具体产品类和工厂子类即可，不用更改工厂父类 每个具体工厂类只负责一个产品的创建，更符合单一职责原则 更利于形成继承结构 缺点 每次增加新产品时，都需要增加工厂类，导致系统复杂度变高 产品和工厂类之间的依赖较大 4. 实现我们将创建一个Product接口和实现Product接口的实体类，工厂接口类Factory和实现Factory接口的实体类 1234567891011121314151617181920212223242526272829303132333435363738394041424344interface Factory &#123; Product getProduct();&#125;interface Product &#123; void show();&#125;class Prouduct1 implements Product &#123; @Override public void show() &#123; System.out.println("我是产品1"); &#125;&#125;class Prouduct2 implements Product &#123; @Override public void show() &#123; System.out.println("我是产品2"); &#125;&#125;class Factory1 implements Factory &#123; @Override public Product getProduct() &#123; return new Prouduct1(); &#125;&#125;class Factory2 implements Factory &#123; @Override public Product getProduct() &#123; return new Prouduct2(); &#125;&#125;public class FactoryMethodPattern &#123; public static void main(String[] args) &#123; Factory factory1 = new Factory1(); factory1.getProduct().show(); Factory factory2 = new Factory2(); factory2.getProduct().show(); &#125;&#125; 输出为： 12我是产品1我是产品2 5. 使用场景但用户只知道产品对应的工厂，而不知道具体产品的类名时可以使用此模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简单工厂模式]]></title>
    <url>%2F2018%2F06%2F15%2F2018-06-15-design-pattern-simple-factory%2F</url>
    <content type="text"><![CDATA[“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。” 1. 简介简单工厂模式是最简单的设计模式之一，简单到甚至没有放到23种常用设计模式当中，可以用于设计模式的入门学习。 2. 目的定义一个创建对象的接口，在工厂中决定实例化哪个对象的子类，解决了接口选择的问题 3. 优缺点 优点 实现了子类对象创建和使用的分离 无需知道子类的类名，通过参数即可创建子类对象 屏蔽了子类的具体实现 缺点 每次增加新产品时，都需要修改工厂类，违反了开闭原则 产品和工厂类之间的依赖较大 4. 实现我们将创建一个Fruit接口和实现Fruit接口的实体类，以及工厂类FruitFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 创建接口interface Fruit &#123; void describe();&#125;// 创建苹果实体类class Apple implements Fruit &#123; @Override public void describe() &#123; System.out.println("我是苹果"); &#125;&#125;// 创建梨实体类class Pear implements Fruit &#123; @Override public void describe() &#123; System.out.println("我是梨"); &#125;&#125;// 创建橙子实体类class Orange implements Fruit &#123; @Override public void describe() &#123; System.out.println("我是橙子"); &#125;&#125;// 创建工厂类class FruitFactory &#123; // 根据给get方法的不同参数名，返回相应的子类 public Fruit getFruit(String name) &#123; if (name == null) &#123; return null; &#125; if (name.equalsIgnoreCase("apple")) &#123; return new Apple(); &#125; else if (name.equalsIgnoreCase("pear")) &#123; return new Pear(); &#125; else if (name.equalsIgnoreCase("orange")) &#123; return new Orange(); &#125; return null; &#125;&#125;public class SimpleFactoryPattern &#123; public static void main(String[] args) &#123; FruitFactory fruitFactory = new FruitFactory(); // 获取苹果对象并调用 describe 方法 Fruit apple = fruitFactory.getFruit("apple"); apple.describe(); // 获取梨对象并调用 describe 方法 Fruit pear = fruitFactory.getFruit("pear"); pear.describe(); // 获取橙子对象并调用 describe 方法 Fruit orange = fruitFactory.getFruit("orange"); orange.describe(); &#125;&#125; 输出为： 123我是苹果我是梨我是橙子 5. 使用场景当我们明确知道传入工厂的参数且对如何创建对象不关心时可以使用此方法，尽量在工厂中创建类型较少时采用此方法，以免工厂类过于复杂。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift 简析]]></title>
    <url>%2F2018%2F05%2F30%2F2018-05-30-thrift-introduction%2F</url>
    <content type="text"><![CDATA[Thrift 是一种可扩展、跨语言的服务开发框架，用于各个服务之间的 RPC 通信。 概述Thrift 最初由 Facebook 于 2007 年开发，2008 年进入 Apache 开源项目。Thrift 主要用于各个服务之间的 RPC 通信，是一种可扩展、跨语言的 RPC 服务开发框架，其服务端和客户端可以用不同的语言来开发。只需要依照 IDL（Interface Description Language）定义一次接口，Thrift 工具就能编译生成 C++, Java, Python, PHP, Ruby, JavaScript, Node.js 等语言的代码。 Thrift 类型Thrift 的类型包括了基本类型，如 bool，byte，double，string 和不同长度的 有符号整数 类型；也提供了特殊类型如 binary，enum，structs，容器类型（list，set，map），exception，service，const 等，也支持类型定义。 基本类型1234567bool: 布尔变量byte: 8 位有符号整数i16: 16 位有符号整数i32: 32 位有符号整数i64: 64 位有符号整数double: 64 位浮点数string: 字符串 其中 i16 类型相当于 short 类型，i32 类型相当于 int 类型，i64 类型相当于 long 类型。 注：Thrift 不支持无符号整数类型，因为很多编程语言不存在无符号类型，比如 Java 特殊类型1binary: 未编码的字节序列 枚举类型1234enum Sex &#123; MALE, FEMALE&#125; 结构体结构体中包含一系列的 强类型 域，目的是聚集一系列数据，类似于无继承的类。 12345struct People &#123; 1: string name, 2: byte age, 3: string gender&#125; 容器类型集合中的类型可以是除了 service 之外的任何类型，包括 exception。 123list: 由 T 类型的数据组成的有序列表，元素可以重复set: 由 T 类型的数据组成的无序集合，元素不可重复map: 字典结构，key 为 K 类型，value 为 V 类型，键不可重复 异常Thrift 支持自定义 exception，规则和 struct 类似： 1234exception RequestException &#123; 1: i32 code, 2: string reason&#125; 服务thrift 定义服务相当于 Java 中创建 Interface，创建的 service 经过代码生成命令之后就会生成客户端和服务端的框架代码。定义形式如下： 1234service HelloWordService &#123; // service 中定义的函数，相当于 Java interface 中定义的函数 string doAction(1: string name, 2: i32 age);&#125; 常量 (const)thrift 也支持常量定义，使用 const 关键字，例如： 12const i32 MAX_RETRIES_TIME = 10const string MY_WEBSITE = "http://qifuguang.me" 类型定义thrift 支持类似 C++ 一样的 typedef 定义，比如： 12typedef i32 Integertypedef i64 Long Thrift 语法命名空间thrift 的命名空间相当于 Java 中的 package，主要目的是组织代码。thrift 使用关键字 namespace 定义命名空间，例如： 1namespace java com.winwill.thrift 文件包含thrift 也支持文件包含，相当于 C/C++ 中的 include，Java 中的 import。使用关键字 include 定义，例 如： 1include "global.thrift" 可选与必选thrift 提供两个关键字 required，optional，分别用于表示对应的字段时必填的还是可选的。例如： 1234struct People &#123; 1: required string name; 2: optional i32 age;&#125; 表示 name 是必需的，age 是可选的。 联合当一个结构体中，field 之间的关系是互斥的，即只能有一个 field 可生效被赋值。我们可以用 union 来声明这个结构体，而不是一堆堆 optional 的 field，语意上也更明确了。例如： 12345678union JavaObjectArg &#123; 1: i32 int_arg; 2: i64 long_arg; 3: string string_arg; 4: bool bool_arg; 5: binary binary_arg; 6: double double_arg;&#125; 注释thrift 注释方式支持 shell 风格的注释，支持 C/C++ 风格的注释，即 # 和 // 开头的语句都单当做注释，/**/ 包裹的语句也是注释。 123456789# 这是一个注释// 这也是一个注释/* * 这是一个多行注释 */struct People &#123; 1: required string name; 2: optional i32 age;&#125; python2 示例定义idl首先我们需要定义一个 idl —— hello.thrift: 123456/*thrift接口定义文件*/service HelloService &#123; string say(1:string msg)&#125; 生成代码运行命令： 1thrift -r -gen py hello.thrift 会生成一个 gen-py 文件夹，里面的 hello 文件夹即为生成的服务 server端代码在 gen-py 目录中新建 server.py 123456789101112131415161718192021222324252627282930# coding: utf-8"""thrift_client.py"""from thrift.protocol import TBinaryProtocolfrom thrift.server import TServerfrom thrift.transport import TSocketfrom thrift.transport import TTransportfrom hello import HelloServiceclass HelloServiceHandler: def say(self, msg): ret = "Received: " + msg print ret return rethandler = HelloServiceHandler()processor = HelloService.Processor(handler)transport = TSocket.TServerSocket("localhost", 9090)tfactory = TTransport.TBufferedTransportFactory()pfactory = TBinaryProtocol.TBinaryProtocolFactory()server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)print "Starting thrift server in python..."server.serve()print "done!" client端代码在 gen-py 目录中新建 client.py 123456789101112131415161718192021222324252627# coding: utf-8"""thrift_client.py"""from thrift import Thriftfrom thrift.protocol import TBinaryProtocolfrom thrift.transport import TSocketfrom thrift.transport import TTransportfrom hello import HelloServicetry: transport = TSocket.TSocket('localhost', 9090) transport = TTransport.TBufferedTransport(transport) protocol = TBinaryProtocol.TBinaryProtocol(transport) client = HelloService.Client(protocol) transport.open() print "client - say" msg = client.say("Hello!") print "server - " + msg transport.close()except Thrift.TException, ex: print "%s" % (ex.message) 运行结果1234567$ python server.pyStarting thrift server in python...Received: Hello!$ ptyhon client.pyclient - sayserver - Received: Hello! 参考1、winwill2010，Thrift 入门教程2、王博文，Python Thrift示例]]></content>
      <categories>
        <category>Thrift</category>
      </categories>
      <tags>
        <tag>RPC</tag>
        <tag>Thrift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPC 简析]]></title>
    <url>%2F2018%2F05%2F29%2F2018-05-29-rpc-introduction%2F</url>
    <content type="text"><![CDATA[RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 概述什么是 RPCRPC，全称为 Remote Procedure Call，即远程过程调用，是一种进程间的通信方式。它能够实现从主机 A 调用可达地址空间中另一台主机 B 上的过程或函数，而程序员并不需要显示的编码其调用过程。也即是说对于程序员来说，这个调用过程是透明的，本地调用和远程调用所用代码基本是相同的。 RPC 的调用过程如下图： client 以本地调用的方式发起一个远程调用 本地的 client stub 接收到调用请求后，将调用的接口、方法和参数通过约定的协议规范进行序列化（ 网络协议基于二进制，需要将内存中的值序列化成为二进制的形式 ） 本地的 RPC 实例将编码结果传输到远端（被调用端）的 RPC 实例 远端 RPC 实例收到请求后交给 server stub 进行反序列化 server stub 调用 server 端本地服务 server stub 获取到本地服务的的返回结果后进行序列化 server 端的 RPC 实例将结果返回给 client 端 client 端接收到返回值后进行反序列化，并将最终的结果返回给发起调用的函数 可以看出 RPC 调用采用的是 C/S 模式。 RPC 需要解决的问题 通讯的问题 主要是通过在客户端和服务器之间建立 TCP 连接，并通过 TCP 连接进行数据交换 寻址的问题 即 A 服务器上的应用如何告诉底层的 RPC 框架，如何连接到 B 服务器的特定端口并调用其特定的方法，比如基于 Web 服务协议栈的 RPC，需要提供一个 endpoint URI 或是从 UDDI 服务上查找 参数的序列化和反序列化 由于方法的参数需要通过底层的网络协议进行传递，而网络协议是基于二进制的，所以需要将内存中参数的值序列化为二进制的形式，并且需要将接收到的二进制数据反序列化恢复为原来内存中的表达方式。 RPC 调用分类根据 Client 端发起调用后是否等待服务端的返回结果，可以将 RPC 调用分为以下两种： 同步调用Client 端发起请求后，挂起本地进程，直到 Server 端运行完毕并返回结果后，唤醒进程继续执行。 异步调用Client 端发起请求后，不等待 Server 端的执行结果，继续运行进程。 若 Client 端需要获取结果，可以通过回调通知等方法获取执行结果。 若 Client 端不需要获取结果，则为单向异步调用，只触发 Server 端的函数执行。 Python 2 简单示例Server 端： 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: utf-8 -*-from SimpleXMLRPCServer import SimpleXMLRPCServer, SimpleXMLRPCRequestHandler# 自定义 RPC 调用地址class RequestHandler(SimpleXMLRPCRequestHandler): rpc_paths = ('/RPC2',)port = 8080# 绑定本地端口 8080 初始化 serverserver = SimpleXMLRPCServer(('localhost', port), requestHandler=RequestHandler)# 注册一个自省的 XML-RPC 函数server.register_introspection_functions()# 注册一个多调用组合server.register_multicall_functions()def add(x, y): return x + y# 注册调用函数, 可以创建别名server.register_function(add, 'addAlias')class MyFuncs: def __init__(self): return def div(self, x, y): return x // y# 注册调用实例, 所有方法将以 XML-RPC 的方式进行发布server.register_instance(MyFuncs())print "Listening on port" + str(port)# 开启 serverserver.serve_forever() Client 端： 123456789101112131415import xmlrpclibport = 8080server = xmlrpclib.ServerProxy("http://localhost:" + str(port))print servermulti = xmlrpclib.MultiCall(server)multi.addAlias(5, 1)multi.div(24, 11)try: for response in multi(): print "Result is :" + str(response)except xmlrpclib.Error, e: print "ERROR", e 输出结果为： 1234567# Server:127.0.0.1 - - [30/May/2018 10:36:19] "POST /RPC2 HTTP/1.1" 200 -# Client&lt;ServerProxy for localhost:8080/RPC2&gt;Result is : 6Result is : 2 参考1、Mindwind，深入浅出 RPC - 浅出篇 2、Mindwind，深入浅出 RPC - 深入篇 3、Way Lau，远程过程调用 (RPC) 详解 4、zhanlijun，你应该知道的RPC原理]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移至 Hexo 博客]]></title>
    <url>%2F2018%2F05%2F04%2F2018-05-04-move-to-hexo-blog%2F</url>
    <content type="text"><![CDATA[Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 之前一直使用的是基于 jekyll 的博客系统，但是功能不是十分的强大，最近老铁安利了 Hexo 这个博客系统，同时也想对自己以前的博文进行整理，所以开始准备将以前基于 jekyll 的博文迁移至 Hexo。 前期准备安装 git 和 node.js安装 Git:Windows：下载并安装 gitMac：brew install gitLinux (Ubuntu, Debian)：sudo apt-get install git-coreLinux (Fedora, Red Hat, CentOS)：sudo yum install git-core 验证安装： 123git version# 输出：# git version 2.7.4 安装 node.js安装 Node.js 的最佳方式是使用 nvm。cURL: 1curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 node.js： 1nvm install stable 当然，也可以根据 官网 教程进行安装。 验证安装： 123node --version# 输出：# v8.11.1 安装 hexo-cli1npm install -g hexo-cli 验证安装： 1234567891011121314151617hexo version# 输出：# hexo-cli: 1.1.0# os: Linux 4.4.0-122-generic linux x64# http_parser: 2.8.0# node: 8.11.1# v8: 6.2.414.50# uv: 1.19.1# zlib: 1.2.11# ares: 1.10.1-DEV# modules: 57# nghttp2: 1.25.0# openssl: 1.0.2o# icu: 60.1# unicode: 10.0# cldr: 32.0# tz: 2017c 恭喜恭喜，至此，Hexo 就安装成功啦！ 备份原博客仓库因为我是迁移博客，所以要备份一下原来的博客，如果你是新建博客的话，可以跳过这一步。 备份原仓库12在 github 中直接将原仓库重命名即可：blogName.github.io -&gt; blogName.github.io.backup 新建空仓库12在 github 中创建一个新的仓库：name: blogName.github.io 初始化并上传博客创建本地 Hexo 项目1234# 在用户根目录创建 Hexo 项目cd ~hexo init blogName.github.iocd blogName.github.io 关联本地 Hexo 项目与 github123456789101112# 将新建的 Hexo 项目进行 git 初始化git initgit add .git commit -m "Hexo 博客，第一次提交"# 将 git 项目与 github 进行关联git remote add origin git@github.com:yourName/blogName.github.io.gitgit push origin master# 使用 gh-pages 分支开发原代码，master 分支用于放置编译后的站点文件git checkout -b gh-pagesgit push --set-upstream origin gh-pages 本地编译并远端部署12345# 在 blogName.github.io 目录下安装已有插件npm install# 安装 Hexo 与 github 的关联插件npm install hexo-deployer-git --save 12345# 修改站点配置文件_configdeploy: type: git repo: git@github.com:yourName/blogName.github.io.git branch: master 1234567# 本地调试hexo s --debug# 部署文件到 master 分支，每次更新博文到 github 都要运行这三个命令，建议写成一个脚本hexo cleanhexo generatehexo deploy 安装 NexT 主题123456# 进入博客项目根目录，创建 next 目录cd ~/blogName.github.iomkdir themes/next# 下载 NexT 主题curl -s https://api.github.com/repos/theme-next/hexo-theme-next/releases/latest | grep tarball_url | cut -d '"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1 配置 NexT 主题请参照 Hexo 的文档 增加站内搜索和阅读量统计功能增加站内搜索功能12# 安装相关插件npm install hexo-generator-searchdb --save 1234567891011# 配置站点_config.xml 文件search: path: search.xml field: post format: html limit: 10000# 配置主题_config.xml 文件# Local searchlocal_search: enable: true 增加阅读量统计功能请参照 为 NexT 主题添加文章阅读量统计功能 一文 其他设置设置 RSS安装插件： 1npm install hexo-generator-feed 在站点配置文件中进行配置： 1234567891011plugin:- hexo-generator-feed# Feed configuration.feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' 参数的含义： type: RSS 的类型 (atom/rss2) path: 文件路径, 默认是 atom.xml/rss2.xml limit: 展示文章的数量, 使用 0 或则 false 代表展示全部 hub: PubSubHubbub hubs 的 URL，如果不用的话请置为空 content: 在 RSS 文件中是否包含内容 , 有 3 个值 true/false 默认不填为 false content_limit: 指定内容的长度作为摘要, 仅仅在上面 content 设置为 false 和没有自定义的描述出现 content_limit_delim: 上面截取描述的分隔符, 截取内容是以指定的这个分隔符作为截取结束的标志。在达到规定的内容长度之前最后出现的这个分隔符之前的内容，防止从中间截断. 配置完成后运行 hexo g，如果在 public 文件夹生成了 atom.xml 文件说明添加成功。 设置阅读全文 在文章中使用 &lt;!-- more --&gt; 关键字进行手动截断 2. 在主题配置文件中添加 123auto_excerpt: enable: true length: 150 设置阅读百分比12# 在主题配置文件中进行设置scrollpercent: true 添加打赏功能1234# 在主题配置文件中进行设置reward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 添加菜单选项生成页面在 blogName.github.io 目录下调用命令： 123456# 添加分类页面hexo new page "categories"# 添加标签页面hexo new page “tags”# 添加关于页面hexo new page "about" 执行完指令后，在 /source/ 文件夹下创建三个文件夹，命名分别为：categories、tags、about 文件夹 修改页面12345---title: 分类date: 2018-05-04 12:06:24type: "categories"--- 12345---title: 标签date: 2018-05-04 12:07:36type: "tags"--- 12345---title: 关于我date: 2018-05-04 12:08:27type: "about"--- 在文章开头添加关键字即可生成相应的 分类 和 标签： 123456789---title: "迁移至 Hexo 博客"date: 2018-05-04 12:00:00categories: - 博客tags: - Hexo - NexT--- 添加社交链接在主题配置文件中修改 social 属性： 12345social: GitHub: https://github.com/yourname || github 知乎: https://www.zhihu.com/people/wenzhiquan/activities E-Mail: mailto:wenzhiquanr@163.com || envelope FB Page: https://www.facebook.com/profile.php?id=100006943363300 || facebook 添加友情链接在主题配置文件中修改 links 属性 1234567# Blog rollslinks_icon: linklinks_title: 友情链接links_layout: block#links_layout: inlinelinks: 肖楚天的博客: https://xiaochutian.github.io/ 添加近期文章在 theme/next/layout/_macro/sidebar.swig 中的 if theme.links 前面添加： 1234567891011121314151617&#123;% if theme.recent_posts %&#125; &lt;div class="links-of-blogroll motion-element &#123;&#123;"links-of-blogroll-"+ theme.recent_posts_layout&#125;&#125;"&gt; &lt;div class="links-of-blogroll-title"&gt; &lt;!-- modify icon to fire by szw --&gt; &lt;i class="fa fa-history fa-&#123;&#123; theme.recent_posts_icon | lower&#125;&#125;" aria-hidden="true"&gt;&lt;/i&gt; &#123;&#123;theme.recent_posts_title&#125;&#125; &lt;/div&gt; &lt;ul class="links-of-blogroll-list"&gt; &#123;% set posts = site.posts.sort('-date') %&#125; &#123;% for post in posts.slice('0', '5') %&#125; &lt;li&gt; &lt;a href="&#123;&#123; url_for(post.path) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125; 并在主题配置文件中添加： 123recent_posts_title: 近期文章recent_posts_layout: blockrecent_posts: true 使用 hexo g 命令重新生成后即可显示 添加字数统计安装插件： 1npm install hexo-symbols-count-time --save 然后在站点配置文件加入： 123symbols_count_time: total_symbols: true total_time: true 并在主题配置文件配置： 123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275 打赏字体不闪动修改文件 next/source/css/_common/components/post/post-reward.styl，然后注释其中的函数 wechat:hover 和 alipay:hover，如下： 12345678910//#wechat:hover p&#123;// animation: roll 0.1s infinite linear;// -webkit-animation: roll 0.1s infinite linear;// -moz-animation: roll 0.1s infinite linear;//&#125;//#alipay:hover p&#123;// animation: roll 0.1s infinite linear;// -webkit-animation: roll 0.1s infinite linear;// -moz-animation: roll 0.1s infinite linear;//&#125; 进度条12# 在主题配置文件中配置pace: true 如果还想继续对博客主题进行配置，请访问我的参考网站。 参考1、Moorez，hexo 的 next 主题个性化教程: 打造炫酷网站 2、hexo 的 next 主题个性化配置教程 3、sunshine 小小倩，hexo 高阶教程 4、打造个性超赞博客 Hexo+NexT+GithubPages 的超深度优化]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 简介]]></title>
    <url>%2F2018%2F04%2F15%2F2018-04-15-spring-introduction%2F</url>
    <content type="text"><![CDATA[“本章将从宏观的层面上介绍 Spring。” 简化 Java 开发Spring 采取 4 种关键策略简化 Java 开发： 基于 POJO 的轻量级和最小侵入性编程 通过依赖注入和面向接口实现松耦合 基于切面和惯例进行声明式编程 通过切面和模板减少样板式代码 POJOSpring 不强迫实现 Spring 规范的接口或继承 Spring 规范的类，最坏的场景是使用了 Sprin 的注解，但他依旧是 POJO。 Spring 赋予 POJO 魔力的方式是通过 DI 来装配他们。 依赖注（Dependenc Injection）依赖注入又可以称为控制反转（IOC，Inversion of Control），通过使用 DI，对象的依赖关系将由系统中负责协调各对象的第三方组件在创建对象时进行设定，对象无需自行创建或管理他们的依赖关系。 依赖注入有四种方式： 构造器注入 setter 注入 静态工厂的方法注入 实例工厂的方法注入 DI 带来的最大收益是 松耦合，创建应用组件之间的行为通常称为 装配（wiring），Spring 支持使用 XM 文件和 Java 文件来进行装配 Spring 通过应用上下文（Applicaiton Context）装载 bea 的定义并把它们组装起来。Spring 应用上下文全权负责对象的创建和组装。 应用切面面向切面编程（Aspect-Oriented Programming) 允许你把遍布应用各处的功能分离出来形成可重用的组件，可以使服务模块化，并以声明的方式将他们应用到他们需要影响的组件中去。 定义方法： 12345678&lt;aop:config&gt; &lt;aop:aspect ref="beanname"&gt; &lt;aop:pointcut id="pointcutId" expression="execution(* *.functionName(..))"/&gt; &lt;aop:before pointcut-ref="pointcutId" method="beforeMethodName"/&gt; &lt;aop:after pointcut-ref="pointcutId" method="afterMethodName"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 使用模板消除样板式代码Spring 的 JdbcTemplate 使得执行数据库操作时，避免传统的 JDBC 样板代码成为了可能。 容纳你的 Bean在基于 Spring 的应用中，应用对象生存在 Spring 容器中，Spring 容器负责创建对象，装配对象，配置对象管理他们的整个生命周期。 容器是 Spring 的核心，Spring 容器使用 DI 管理构成应用的组件，他会创建相互协作的组件之间的关联。 使用应用上下文Spring 自带多种类型的应用上下文，常用的有以下几种： AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文 AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文 ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源 FileSystemXmlApplicationContext：从文件系统下的一个或多个 XMl 配置文件中加载上下文定义 XmlWebApplicationContex：从 Web 应用的一个或多个 XML 配置文件中加载上下文定义 Bean 的生命周期Spring 容器中的 Bean 生命周期比较复杂，如下图： 实例化 Bean当客户向容器请求一个尚未初始化的 Bean 时，或初始化 Bean 时需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 方法进行实例化，实例化对象呗包装在 BeanWrapper 对象中，BeanWrapper 提供了设置对象属性的接口，这个步骤没有进行依赖注入。 设置对象属性Spring 根据 BeanDefinition 中的信息，将值和 Bean 的引用通过 BeanWrapper 提供的设置属性的接口注入到 Bean 对应的属性中。 调用 setBeanName() 方法如果 Bean 实现了 BeanNameAware 接口，Spring 将 Bean 的 ID 传递给 setBeanName(String beanId) 方法 调用 setBeanFactory() 方法如果 Bean 实现了 BeanFactoryAware 接口，Spring 将调用 setBeanFactory() 方法，传入 BeanFactory 容器。 调用 setApplicationContext() 方法如果 Bean 实现了 ApplicationContextAware 接口，Spring 将调用 setApplicationContext() 方法，传入 Bean 所在的应用上下文的引用。 调用 BeanPostProcessor 接口的 postProcessBeforeInitialization() 方法如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用他们的 postProcessBeforeInitialization() 方法，当前正在初始化的对象会被传递进来，我们就可以对这个 Bean 做任何处理，此函数会先于 InitializationBean 执行，因此称为前置处理，所有 Aware 接口的注入 就是在这一步完成的。 调用 InitializingBean 接口的 afterPropertiesSet() 方法当前置处理完成后进入本阶段，本阶段可以在 Bean 正式构建前增加我们自定义的逻辑，但是由于并没有把 Bean 对象传递进来，因此本阶段无法处理对象本身，只能增加一些额外的逻辑。 若要使用他，需要让 Bean 实现该接口，并把要增加的逻辑写入该函数当中，Spring 火灾前置处理完成后检测当前 Bean 是否实现了该接口，并执行该函数。 类似地，Spring 为 Bean 的配置提供了 init-method 属性，该属性指定了在本阶段需要执行的函数名，Spring 会在初始化阶段执行设置的函数。init-method 本质上也是使用了 InitializingBean 接口。 调用 BeanPostProcessor 接口的 postProcessAfterInitialization() 方法如果 Bean 实现了 BeanPostProcessor 接口，Spring 将调用他们的 postProcessAfterInitialization() 方法，当前正在初始化的 Bean 对象会被传递进来，我们可以对这个对象做任何处理，这个函数回来 InitializingBean 完成后执行，因此成为后置处理。 准备就绪此时，Bean 已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到被该应用上下文销毁。 调用 DisposableBean 接口的 destroy() 方法如果 Bean 实现了 DisposableBean 接，Spring 将调它的 destroy()方法，可以在 Bean 销毁前执行指定的逻辑，类似的，通过给 destroy-method 属性指定函数，可以在 Bean 小回迁执行这个函数]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类文件结构和Java虚拟机类加载机制]]></title>
    <url>%2F2018%2F04%2F01%2F2018-04-01-java-class-load%2F</url>
    <content type="text"><![CDATA[“代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。” 概述虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 在 Java 语言中，类的加载、连接和初始化过程都是在程序运行期间完成的，为 Java 应用程序提供了高度的灵活性。 Class 类文件的结构任何一个 Class 文件都对应着唯一一个类或者接口的定义信息。Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在 Class 文件之中，中间没有任何分隔符，所以整个 Class 文件中存储的内容几乎全是程序运行的必要数据。，遇到占用 8 位字节以上空间的数据项目时，会按照高位在前的方式分割成若干个 8 位字节进行存储。 Class 文件中只有两种数据类型：无符号数和表 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以_info结尾 Class 文件格式如下： 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attributes_count 1 attribute_info attributes attributes_count 无符号数属于基本的数据类型，用 u1、u2、u4、u8 里奥表示 1 个字节、2 个字节、4 个字节、8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值和按照 UTF-8 编码构成的字符串值。 魔数与 Class 文件的版本每个 Class 文件的开头 4 个字节称为魔数，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的 Class 文件，值为0xCAFEBABE。 紧接着魔数的 4 个字节存储的是 Class 文件的版本号，第 5 和第 6 字节是次版本号，第 7 和第 8 字节是主版本号，虚拟机必须拒绝执行超过其版本号的 Class 文件 常量池紧接着主次版本号之后的是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，他是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同时还是在 Class 文件中第一个出现的表类型数据项目。 由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值，这个容量计数是从1开始的，其他的集合类型都是从 0 开始的。因为将常量池索引置为 0 被设计用来表示不引用任何一个常量池项目。 常量池主要存放两大类常量：字面量和符号引用 字面量比较接近 Java 语言层面的常量概念，如文本字符串、声明为final的常量值等 符号引用属于编译原理方面的概念，包括以下三类常量： 类和接口的全限定名 字段的名称和描述符 方法的名称和描述符 当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。 常量中每一项常量都是一个表，目前一共有 14 种常量类型，他们均有各自的结构。 可以通过javap -verbose命令查看 Class 文件的字节码内容。 访问标志在常量池结束之后，紧接着的两个字节代表访问标志（access_flags),这个标志用于识别以下类或者接口层次的访问信息。 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为 public 类型 ACC_FINAL 0x0010 是否被声明为 final，只有类可设置 ACC_SUPER 0x0020 是否允许使用 invokespecial 字节码指令的新语意，JDK1.0.2 之后编译出来的类此标志都必须为真 ACC_INTERFACE 0x0200 标识这是一个接口 ACC_ABSTRACT 0x0400 是否为 abstract 类型，对于接口或抽象类来说，此标志值为真 ACC_SYNTHETIC 0x1000 标识这个类并非由用户代码产生的 ACC_ANNOTATION 0x2000 标识这是一个注解 ACC_ENUM 0x4000 标识这是一个枚举 access_flags 的值由上述标志值求或操作获得。 类索引、父类索引和接口索引集合类索引(this_class)和父类索引(super_class)都是一个 u2 类型的数据，而接口索引集合(interfaces)是一组 u2 类型的数据集合，Class 文件中由这三项数据来确定这个类的继承关系。 类索引用于确定这个类的全限定名。 父类索引用于确定这个类的父类的全限定名。 接口索引集合用来描述这个类实现了哪些接口，按照 implements 语句后的接口顺序从左到右排列在接口索引集合中。 类索引和父类索引引用两个 u2 类型的索引值表示，他们各自指向一个类型为 CONSTANT_Class_info 的类描述符常量，通过 CONSTANT_Class_info 类型的常量中的索引值可以找到定义在 CONSTANT_Utf8_info 类型的常量中的全限定名字符串。 字段表集合字段表(field_info)用于描述接口或者类中声明的变量，字段(field)包括类级变量以及实例级变量，但不包括局部变量。 字段表结构如下： 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attributes_count 1 attribute_info attributes attributes_count 字段修饰符放在 access_flags 项目中，他与类中的 access_flags 项目非常类似，结构如下： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 字段是否为 public ACC_PRIVATE 0x0002 字段是否为 private ACC_PROTECTED 0x0004 字段是否为 private ACC_STATIC 0x0008 字段是否为 static ACC_FINAL 0x0010 字段是否为 final ACC_VOLATILE 0x0040 字段是否为 volatile ACC_TRANSIENT 0x0080 字段是否为 transient ACC_SYNTHETIC 0x1000 字段是否由编译器自动产生 ACC_ENUM 0x4000 字段是否枚举 跟随 access_flags 标志的是两项索引值：name_index 和 descriptor_index，他们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。 方法表集合Class 文件存储格式中对方法的描述与对字段的描述几乎一致。 方法表结构如下： 类型 名称 数量 u2 access_flags 1 u2 name_index 1 u2 descriptor_index 1 u2 attributes_count 1 attribute_info attributes attributes_count 方法表的访问标志结构如下： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 方法是否为 public ACC_PRIVATE 0x0002 方法是否为 private ACC_PROTECTED 0x0004 方法是否为 private ACC_STATIC 0x0008 方法是否为 static ACC_FINAL 0x0010 方法是否为 final ACC_SYNCHRONIZED 0x0020 方法是否为 synchronized ACC_BRIDGE 0x0040 方法是否为编译器产生的桥接方法 ACC_VARARGS 0x0080 方法是否接收不定参数 ACC_NATIVE 0x0100 方法是否为 native ACC_ABSTRACT 0x0200 方法是否为 abstract ACC_STRICTFP 0x0400 方法是否接为 stricttfp ACC_SYNTHETIC 0x1000 方法是否由编译器自动产生 属性表集合在 Class 文件、字段表、方法表都可以携带自己的属性表集合。总共有 21 项预定义的属性，如下： 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载共 7 个阶段。其中验证、准备和解析 3 个部分统称为连接。如下图所示： 其中，加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，因为这些阶段通常都是相互交叉地混合式进行的，通常会在一个阶段执行的过程中调用、激活另外一个阶段。 对于初始化阶段，严格规定了有且只有5 种情况必须立即对类进行初始化： 遇到 new、getstatic、putstatic 和 invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条指令的最常见的 Java 代码场景是: 使用 new 关键字实例化对象的时候； 读取或设置一个类的静态字段（被 final 修饰，已在编译器把结果放入常量池的静态字段除外）的时候； 调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要制定一个要执行的主类（包含 main()方法的类），虚拟机会先初始化这个主类 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果是 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化 这 5 种场景中的行为被称为对一个类进行主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。 接口的初始化与类只在第 3 种场景有区别：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口都完成了初始化，只有在真正使用到父接口时才会初始化。 类加载的过程加载加载是类加载过程中的一个阶段，在加载阶段，虚拟机完成以下 3 件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 一个非数组类在加载阶段，即可以使用系统提供的引导类加载器去控制字节流的获取方式，也可以有用户自定义的类加载器去完成 数组类本身不通过类加载器创建，而是由 Java 虚拟机直接创建的，其（简称 C）创建过程遵循以下规则： 如果数组的组件类型（指数组去掉一个维度的类型）是引用类型，递归采用加载过程区加载这个组件类型，数组 C 将在加载该组件类型的类加载器的类名称空间上被标识 如果数组的组件类型不是引用类型，Java 虚拟机将会把数组 C 标记为与引导类加载器关联 数组类的可见性与他的组件类型的可见性一致，如果组件类型不是引用类型，数组类的可见性默认为 public 加载阶段完成后，虚拟机外部的二进制字节流就会按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机实现自定义，然后会在内存中实例化一个 java.lang.Class 类的对象，HotSpot 中这个对象存放在方法区中，这个对象将作为程序访问方法区中类型数据的外部接口。 验证验证是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。 验证阶段大致上会完成下面 4 个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证 文件格式验证：主要验证字节流是否符合 Class 文件的格式规范 元数据验证：对字节码描述的信息进行语义分析，保证其描述的信息符合 Java 语言规范的要求 字节码验证：是最复杂的验证阶段，目的是通过数据流和控制流分析，确定程序语意是合法的、符合逻辑的 符号引用验证：发生在虚拟机将符号引用转化为直接引用时，目的是确保解析动作能正常进行 验证阶段是非常重要但是非必要的阶段，如果运行的全部代码都已经被反复使用和验证过，可以考虑使用-Xverify:none 参数关闭大部分类验证措施，缩短虚拟机类加载时间 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量将在方法区进行内存分配。 如果类字段的字段属性表中存在 ConstantValue 属性，准备阶段变量会被初始化为 ConstantValue 属性所指定的值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄 初始化类初始化阶段才真正开始执行类中定义的 Java 程序代码，是执行类构造器()方法的过程。 ()方法是有编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的 ()方法与类的构造函数不同，他不需要显式调用父类构造器，虚拟机会保证父类的()方法先执行，所以第一个被执行的()方法一定是 java.lang.Object 由于父类()方法先执行，所以父类中定义的静态语句块要优先于子类变量的赋值操作 ()方法对于类或接口来说不是必需的，如果类中没有静态语句块和对变量的赋值操作，则不为这个类生成()方法 接口的()方法不需要先执行父类的()方法，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类初始化时也不会执行接口的()方法 虚拟机会保证一个类的()方法在多线程环境中被正确的加锁、同步 类加载器类加载阶段的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作被设计放到 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为类加载器。 类与类加载器对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 双亲委派模型从 Java 虚拟机的角度来讲，只存来两种不同的类加载器：启动类加载器和其他类加载器 从 Java 开发人员的角度来看，大部分 Java 程序会使用一下三种系统提供的类加载器： 启动类加载器（Bootstrap ClassLoader）：将存放在&lt;JAVA_HOME&gt;/lib 目录中的，或被-Xbootclasspath 参数指定路径中的，且被虚拟机是别的类库加载到虚拟机内存中 扩展类加载器（Extension ClassLoader）：将存放在&lt;JAVA_HOME&gt;/lib/ext 目录中的，或呗 java.ext.dirs 系统变量指定路径中的所有类库加载到虚拟机内存中 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（ClassPath）上所指定的类库 图中展示的类加载器之间的层次关系，称为类加载器的双亲委派模型，该模型要求除了启动类加载器外，其余的类加载器都应当有自己的父类加载器。类加载器的父子关系都是使用组合关系来复用父加载器的 双亲委派模型的工作过程是：如果一个类加载器收到了类加载请求，他首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的家在请求最终都应该传送到顶层的启动类加载器中，只有当父加载器在其搜索范围内没有找到所需的类时，子加载器才会尝试去加载。 双亲委派模型的代码都集中在 java.lang.ClassLoader 的 loadClass()方法中，代码如下： 12345678910111213141516171819202122232425protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException&#123; // 首先检查请求的类是否应经被加载过了 Class c = findLoadedClass(name); if(c == null)&#123; try&#123; if(parent != null)&#123; c = parent.loadClass(name,false); &#125;else&#123; c = findBootstrapClassOrNull(name); &#125; &#125;catch(ClassNotFoundException e)&#123; // 如果父类加载器抛出ClassNotFoundException // 说明父类无法完成加载请求 &#125; if(c == null)&#123; // 在父类加载器无法加载的时候 // 再调用本身的findClass()方法来进行类加载 c = findClass(name); &#125; &#125; if(resolve)&#123; resolveClass(c); &#125; return c;&#125; 代码逻辑为：先检查是否已经被加载过，若没有加载则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 后，再调用自己的 findClass()方法进行类加载。 破坏双亲委派模型双亲委派模型不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。到目前为止，出现过 3 次较大规模的“被破坏”情况。 双亲委派模型在 JDK1.2 之后引入，为了向前兼容，在 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass() 为了解决基础类需要调用会用户代码的问题，引入了一个不太优雅的设计：线程上下文类加载器，父类加载器可以通过他请求子类加载器去完成类加载动作 由于用户对程序动态性的追求而导致，例如 OSGi 的网状结构 只要有足够的理由和意义，突破已有的原则就可以认为是一种创新。 参考 1、周志明，深入理解 Java 虚拟机：JVM 高级特性与最佳实践，机械工业出版社 2、xiedacon，《深入理解 java 虚拟机》-类文件结构]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类文件结构</tag>
        <tag>类加载机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型和垃圾回收]]></title>
    <url>%2F2018%2F03%2F28%2F2018-03-28-java-memory-garbage-collection%2F</url>
    <content type="text"><![CDATA[“Java 与 C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。” 运行时数据区域按照 java 虚拟机规范，抽象的 Java 虚拟机如下图所示： 程序计数器每条线程都有一个独立的程序计数器，用于记录当前线程所执行的字节码的行号。如果执行的是 java 方法，计数器记录的是虚拟机字节码指令的地址，如果是本地方法，则计数器值为空。 Java 虚拟机栈Java 虚拟机栈也是线程私有的，和线程的生命周期相同。 虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个栈帧在虚拟机中入栈到出栈的过程，对应了一个方法从调用到执行完成的过程。当进入一个方法时，这个方法需要在帧中分配多大的局部变量表是完全确定的，在方法运行期间局部变量表的大小不会改变。 其中局部变量表是我们最为关注的部分，他存放了编译期可知的 8 种基本类型数据、对象引用和returnAddress类型。 本地方法栈本地方法栈和虚拟机栈作用类似，不过是为虚拟机要使用的本地方法提供服务。 Java 堆Java 堆是 Java 虚拟机管理的内存中最大的一部分。他是被所有线程共享的一块内存区域，在虚拟机启动时创建。Java 堆的目的是存放对象实例，基本上所有的对象和数组都需要在堆上进行分配。 Java 堆也是垃圾收集器管理的主要区域。 方法区方法区也是被各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量和即时编译器编译后的代码等数据。 方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。 运行时常量池Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。 而运行时常量池相对于 Class 文件常量池的特征是具备动态性，只有没预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，比如 String 的 intern()方法。 对象对象的创建虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。若没有，需要先执行相应的类加载过程。 在类加载检查通过后，虚拟机会为新生对象分配内存，分配方式一般有两种：指针碰撞和空闲列表。当 Java 堆中的内存规整时，直接把指针挪动对象大小的距离即可，即指针碰撞；如果 Java 堆中的内存不规整，需要维护一个记录哪些内存可用的列表，分配时从列表中给对象分配空间，即空闲列表。 内存分配完成后，虚拟机需要将分配的内存空间初始化为零值。 然后，虚拟机要对对象进行必要的设置。将在对象头中设置对象是哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 最后，会执行对象的&lt;init&gt;方法，把对象按照程序员的意愿进行初始化。 对象的内存布局在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为 3 块区域：对象头、实例数据和对齐填充。 对象头包括两部分信息： 第一部分用于存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志线程持有的锁、偏向线程 ID、偏向时间戳等。 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据部分是对象真正存储的有效信息，HotSpot 分配策略中，相同宽度的字段总是被分配到一起，满足这个条件的前提下，在父类中定义的变量会出现在子类之前。 对齐填充是非必须的，仅仅起到占位符的作用，由于 HotSpot 虚拟机的自动内存管理系统要求对象的起始地址必须是 8 字节的整数倍，所以当对象实例数据部分没有对齐时，需要通过对齐填充来补全。 对象的访问定位主流的访问方式有两种：句柄和直接指针两种。 句柄：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的是对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体信息。优点是当对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要改变。 直接指针：Java 堆对象的布局中放置了访问类型数据的相关信息，reference 中存储的是对象地址。优点是速度更快，节省了一次指针定位的开销。 HotSpot 使用直接指针的方式进行对象访问 垃圾收集器与内存分配策略第一节我们提到，程序计数器、虚拟机栈、本地方法栈三个区域随线程生，随线程灭，每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。而 Java 堆和方法区不同，我们只有在程序运行期间才能确定会创建那些对象，这部分的内存分配和回收都是动态的，垃圾回收时主要关注的是这部分的内存。 判断对象是否存活垃圾收集器进行垃圾回收前，首先需要判断那些对象还是存活的。 引用计数法给对象添加一个引用计数器，每当有引用时计数器加 1，引用失效时计数器减 1，计数器为 0 的对象就是“垃圾对象”。 优点：实现简单，判定效率高。 缺点：很难解决对象之间的循环引用问题。 可达性分析法通过一系列被称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到 GC Root 没有任何引用链相连时，证明此对象是“垃圾对象”。 Java 语言中，可作为 GC Roots 的对象有： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI 引用的对象 ###＃ 对象的自我拯救 对象可以通过覆盖 finalize()方法，在其中和引用链上的任何一个对象建立关联，逃过一次垃圾回收，但因为每个对象的 finalize()方法只会被系统自动调用一次，所以对象最多通过这种方式逃过一次垃圾回收。不过这种方式并不被推荐使用。 回收方法区方法区的垃圾回收主要有：废弃常量和无用的类 当一个常量池中的常量（字面量和符号引用）没有被在任何地方被引用，且发生了内存回收的话，这个常量就会被清理出常量池。 无用的类： 该类的所有实例都已经被回收 加载该类的 ClassLoader 已经被回收 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问 垃圾回收算法G1 之前的垃圾回收算法，将堆划分为如下结构： 新生代：eden space + 2 个 survivor 老年代：old space 永久代：1.8 之前的 perm space 元空间：1.8 之后的 metaspace 标记清除（Mark-Sweep）算法首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 不足：效率较低，标记清除后会产生大量不连续的内存碎片 复制（Copying）算法将内存划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后把已经使用过的内存空间全部清理掉。 优点：实现简单，运行高效缺点：讲内存缩小为原来的一半，过于浪费空间 IBM 研究表明，新生代中的对象 98%都是“朝生夕死”的，所以不需要按照 1:1 来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 空间。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是8:1，所以只有 10%的空间会被“浪费”，可以通过-XX:SurvivorRatio 参数调整这个比例。 复制算法在对象存活率较高时，需要进行较多的复制操作，而且需要额外的空间进行分配担保，所以老年代一般不能直接选用这种算法。 标记整理（Mark-Compact）算法首先对存活的对象进行标记，然后将所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。 垃圾收集器收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。HotSpot 包含的垃圾收集器如图所示： 到目前为止，没有最好的收集器，我们应该针对具体的使用场景选择最合适的垃圾收集器。 Serial 收集器这个收集器是一个单线程收集器，使用复制算法，他会在进行垃圾收集时，暂停所有其他的线程，直到收集结束。其运行过程如下： 由于其简单而高效（与其他收集器的单线程相比，没有线程交互的开销），他依然是虚拟机运行在 Client 模式下的默认新生代收集器。 ParNew 收集器ParNew 收集器是 Serial 收集器的多线程版本，使用复制算法，工作过程如下： 他是运行在 Server 模式下的虚拟机中首选的新生代收集器，其中一个很重要的原因是只有 Serial 收集器和 ParNew 收集器可以和 CMS 收集器配合工作。 ParNew 默认开启的收集线程数与 CPU 数量相同，在 CPU 很多的环境下，可以使用-XX:ParallelGCThreads 参数来限制垃圾回收的线程数。 Parallel Scavenge 收集器此收集器也是使用复制算法的收集器，但他的关注点是达到可控制的吞吐量，所以也被称为”吞吐量优先“收集器。 1吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) 此收集器比较适用于需要与用户交互的程序和后台运算较多的程序。 它提供了两个参数用于精确控制吞吐量： 最大垃圾收集停顿时间： -XX:MaxGCPauseMillis，参数值是一个大于 0 的毫秒数 设置吞吐量大小： -XX:GCTimeRatio，参数值一个[0, 100)的整数，也就是垃圾收集时间占总时间的比率，1 / (1 + N)，默认值是 99 此收集器还有一个参数-XX:+UseAdaptiveSizePolicy，开启后虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间或最大的吞吐量，被称为GC自适应的调节策略。 Serial Old 收集器此收集器是 Serial 收集器的老年代版本，使用单线程和”标记整理“算法，主要用于 Client 模式的虚拟机。 如果在 Server 模式下，还有两大用处： 在 JDK 1.5 之前与 Parallel Scavenge 收集器搭配使用 作为 CMS 收集器的后备预案 Parallel Old 收集器此收集器是 Parallel Scavenge 的老年代版本，使用多线程和”标记整理“算法。 在注重吞吐量 CPU 资源敏感的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器，工作过程如下： CMS（Concurrent Mark Sweep）收集器此收集器是一种以获取最短回收停顿时间为目标的收集器，使用”标记清除“算法。 过程分为四步： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中，初始标记和重新标记还是需要”Stop The World“。 初始标记仅仅标记可以和 GC Roots 关联到的对象 并发标记进行 GC Roots Tracing 重新标记用于修正并发标记期间因为用户程序继续运行导致标记产生变动的对象的标记记录 整个回收过程中，耗时最长的是并发标记和并发清除过程，但这两个过程都是可以和用户线程一起工作的，所以从总体上说，CMS 收集器的内存回收过程和用户线程是并发执行的。 优点： 并发手机、低停顿 缺点： 对 CPU 资源非常敏感，并发阶段会导致总吞吐量降低 无法处理浮动垃圾，需要预留一部分空间提供给并发收集时的程序运作，如果 CMS 运行期间预留的内存无法满足程序需要，会触发一次”Concurrent Mode Failure“失败，临时启用 Serial Old 收集器。 会产生大量的内存碎片，提供-XX:+UseCMSCompactAtFullCollection 参数（默认开启），用于要进行 FullGC 时开启内存碎片的合并整理过程，还提供了一个-XX:CMSFullGCsBeforeCompaction，用于设置执行多少次不压缩的 FullGC 后，再进行一次带压缩的（默认值为 0） G1 收集器此收集器是一款面向服务端应用的垃圾收集器，其特点有： 并行与并发，使用多核减少 STW 停顿时间，GC 动作通过并发方式让 Java 程序继续执行 分代收集 空间整合，整体是基于”标记整理“算法实现的，局部是基于”复制“算法实现的，不会产生内存空间碎片 可预测的停顿，可以指定在长度为 M 毫秒的时间片断内，垃圾收集时间不超过 N 毫秒 G1 收集器将整个 Java 堆划分为多个大小相等的独立区域（Region），并跟踪各个 Region 里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的时间，优先回收价值最大的 Region。每个 Region 是逻辑上连续的一段内存。结构如下： 其中当新建对象大小超过 Region 大小一半时，会直接在一个或多个新的连续 Region 中分配此对象，并标记为 Humongous 对象。 RegionRegion 的大小为 1M——32M 的 2 的 N 次幂，默认数量为 2048 个，如果 G1HeapRegionSize 为默认值，则会在堆初始化时计算 Region 的实际大小。 在 G1 收集器中，垃圾回收只回收一部分 Region，所以回收时需要知道 Region 之间的对象引用，在使用复制算法移动对象时，需要更新引用为对象的新地址。这种分代收集中，年轻代垃圾收集时，需要老年代到年轻代的引用记录，通常称为 Remembered Set。当虚拟机发现程序在对 Reference 类型的数据进行写操作时，会场生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否处于不同的 Region 之间，如果是，则通过 CardTable 讲相关引用信息记录到被引用对象所属 Region 的 Remembered Set 中。 GC 模式G1 中一共有三种垃圾回收的模式：Young GC、Mixed GC 和 Full GC。 Young GC 对象优先在 Eden Region 中进行分配，当所有 Eden Region 被耗尽时，会触发一次 Young GC，存活的对象会被复制到 Survivor Region 中，空闲的 Region 被放入空闲列表中 Mixed GC 当越来越多的对象进入 Old Region 时，虚拟机会触发一次 Mixed GC，回收整个 Young Region 和部分Old Region，触发时机通过-XX:InitiatingHeapOccupancyPercent=N，则当老年代大小占整个堆的 N%时，会触发一次 Mixed GC，过程类似于 CMS Full GC 如果对象内存分配速度过快，Mixed GC 来不及回收导致老年代被填满，会触发一次 Full GC，使用 Serial Old 方式进行垃圾回收 G1 工作过程G1 的工作过程如下： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 初始标记阶段仅仅只是标记一下 GC Roots 能够直接关联的对象，并且修改 TAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行的时候，能在正确可用的 Region 中创建新对象，这个阶段需要暂停线程。并发标记阶段从 GC Roots 进行可达性分析，找出存活的对象，与用户线程并发执行。最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在 Remembered Set Logs 中，最终标记阶段再把 Logs 中的记录合并到 Remembered Set 中，这个阶段是并行执行的，需要暂停用户线程。最后在筛选阶段首先对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间制定回收计划。 内存分配与回收策略 对象优先在 Eden 分配 大多数情况下，对象在新生代的 Eden 区中分配，当 Eden 区空间不足时，虚拟机会发起一次 Minor GC 大对象直接进入老年代 所谓大对象，最典型的就是长字符串和数组。 长期存活的对象进入老年代 对象晋升到老年代的年龄阈值，可以通过-XX:MaxTenuringThreshold 设置，默认为 15 岁 动态对象年龄判断 如果在 Survivor 空间中相同年龄的所有对象大小的总和超过 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。 参考 1、周志明，深入理解 Java 虚拟机：JVM 高级特性与最佳实践，机械工业出版社 2、占小狼，G1 垃圾收集器介绍]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内存模型</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--简介]]></title>
    <url>%2F2018%2F02%2F25%2F2018-02-25-design-pattern-intro%2F</url>
    <content type="text"><![CDATA[“设计模式是软件开发人员在开发过程中可以遵循的一般问题的解决方案。” 1. 简介所谓模式，就是在特定环境下人们对某类重复出现的问题提出的一套有效的解决方案。 而设计模式(Design Pattern)，则是针对软件设计过程中，可能遇到的重复问题的合理解决方案。 设计模式提出的根本目的就是解决现实生活中的问题，每种设计模式都有对应的现实问题及其解决方案，找到对应的问题便能够快速的利用设计模式进行解决。 设计模式一般包含模式名称、解决的问题，解决方案和应对效果等部分。 使用设计模式的目的是为了提高代码的可重用性；按照一定的规则编写代码，能够让自己的代码更加容易被其他编程人员所理解；同时，在一定的规则内编写代码，可以在一定程度上提升代码的可靠性。 2. 设计模式的类型根据设计模式的参考书Design Patterns - Elements of Reusable Object-Oriented Software中所提到的，总共有 23 种设计模式。 常用设计模式一览： 类型 模式名称 使用频率 创建型模式 工厂方法模式 Factory Method Pattern ★★★★★ 创建型模式 抽象工厂模式 Abstract Factory Pattern ★★★★★ 创建型模式 单例模式 Singleton Pattern ★★★★☆ 创建型模式 简单工厂模式 Simple Factory Pattern ★★★☆☆ 创建型模式 原型模式 Prototype Pattern ★★★☆☆ 创建型模式 建造者模式 Builder Pattern ★★☆☆☆ – – – 结构型模式 外观模式 Façade Pattern ★★★★★ 结构型模式 代理模式 Proxy Pattern ★★★★☆ 结构型模式 适配器模式 Adapter Pattern ★★★★☆ 结构型模式 组合模式 Composite Pattern ★★★★☆ 结构型模式 桥接模式 Bridge Pattern ★★★☆☆ 结构型模式 装饰模式 Decorator Pattern ★★★☆☆ 结构型模式 享元模式 Flyweight Pattern ★☆☆☆☆ – – – 行为型模式 迭代器模式 Iterator Pattern ★★★★★ 行为型模式 观察者模式 Observer Pattern ★★★★★ 行为型模式 策略模式 Strategy Pattern ★★★★☆ 行为型模式 命令模式 Command Pattern ★★★★☆ 行为型模式 模板方法模式 Template Method Patter ★★★☆☆ 行为型模式 状态模式 State Pattern ★★★☆☆ 行为型模式 中介者模式 Mediator Pattern ★★☆☆☆ 行为型模式 备忘录模式 Memento Pattern ★★☆☆☆ 行为型模式 职责链模式 Chain of Responsibility Pattern ★★☆☆☆ 行为型模式 访问者模式 Visitor Pattern ★☆☆☆☆ 行为型模式 解释器模式 Interpreter Pattern ★☆☆☆☆ 3. 面向对象设计的几大原则1. 单一职责原则（Single Responsibility Principle）简单来说就是一个类只负责一个功能，这样一个类的职责就不会出现大量耦合，重用性也会更高。 2. 开闭原则（Open-Closed Principle）一个软件应当对扩展开放，而对修改关闭。即软件应当尽量在不修改原代码的基础上进行扩展。想要达到这个效果，需要使用接口和抽象类。 3. 里氏代换原则（Liskov Substitution Principle）任何可以使用基类的地方，其子类一定也能够被使用。按照里氏原则，子类必须实现父类的所有方法，当我们设计父类时，尽量把父类设计为抽象类或接口，这样运行时子类替换父类实例，可以很轻松的扩展系统功能。 4. 依赖倒置原则（Dependency Inversion Principle）抽象不应该依赖于细节，而细节应该依赖于抽象。即我们应该面向接口编程，而不是针对实现编程。一个具体类应当只实现接口或抽象类中声明过的方法，而不应给出多余的方法。 5. 接口隔离原则（Interface Segregation Principle）使用多个隔离的接口，而不是使用单一的接口，即当一个接口太大时，我们应当将其分割为隔离的多个接口，可以减小类之间的耦合。 6. 合成复用原则（Composition/Aggregate Reuse Principle）尽量使用对象组合，而不是继承来达到复用的目的。 7. 迪米特法则（Law of Demeter）一个软件的实体应当尽可能少的和其他实体发生相互作用，而成为一个独立的模块。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA和gradle创建超市管理系统（贰）-- 登录注册功能]]></title>
    <url>%2F2017%2F02%2F05%2F2017-02-05-idea-gradle-tssm-supermarket-manage-system-2%2F</url>
    <content type="text"><![CDATA[“IDEA是jetbrains公司开发的Java开发IDE，功能齐全。使用IDEA搭建SSM开发环境简单有效。本项目基于Spring，Spring MVC和MyBatis进行开发，模板引擎为Thymeleaf。” 主要功能概述因为是为超市定制的管理系统，所以只会有内部人员进行使用，这就意味着新用户是需要拥有权限的人来进行添加，故需要实现的功能主要包括以下两点： 用户添加 用户登录 这两点功能中又包含了一些更细小的功能，将在后续章节进行详细的介绍。 后台前端模板由于本人不擅长前端页面的编写，故采用了开源的后台系统模板进行改造，后台系统模板的名称为Gentallela，下载地址是在作者的Github，感兴趣的同学可以前往下载。 用户添加功能用户添加功能分为以下几个步骤进行完成： 添加数据库 编写对应的model 编写对应的mapper 编写对应的service 编写对应的controller 编写对应的js请求和前端页面 添加数据库首先需要建立一个user表，用于存储用户信息。 123456789101112CREATE TABLE `user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户ID', `username` varchar(20) NOT NULL DEFAULT '' COMMENT '用户名', `password` varchar(32) NOT NULL DEFAULT '' COMMENT '用户密码', `email` varchar(45) NOT NULL COMMENT '用户邮箱', `salt` int(4) NOT NULL COMMENT '盐', `authority` int(2) NOT NULL DEFAULT '0' COMMENT '用户身份', `status` int(1) NOT NULL DEFAULT '1' COMMENT '账户状态', `created_time` datetime NOT NULL COMMENT '创建时间', `updated_time` datetime NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 其中salt的作用是和password一起作用生成一个不可破解的密码，加密方式用的是MD5加密。 编写User类User类中的属性和数据库的字段是一一对应的。 1234567891011public class User &#123; private int id; private String username; private String password; private String email; private int salt; private int status; private Date createdTime; private Date updatedTime; // 需要生成所有属性的get和set方法。 编写UserMapper接口和UserMapper.xml文件UserMapper接口为UserService提供可以调用的数据库操作接口。 123456789@Repositorypublic interface UserMapper &#123; // 由于接口方法默认且必须是public的，所以无需添加此关键字 User selectByName(String name); User selectByEmail(String name); int addUser(User user);&#125; 而UserMapper.xml用于实现具体的数据库调用方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org/DTD Mapper 3.0" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace必须和UserMapper接口相对应 --&gt;&lt;mapper namespace="cn.edu.bupt.wen.mapper.UserMapper"&gt; &lt;!-- 自定义返回结果集 --&gt; &lt;!-- 由于Mybatis无法自动将DateTime类型和java.util.Date类型进行自动映射，故需要手动配置 --&gt; &lt;resultMap id="userMap" type="User"&gt; &lt;id property="id" column="id" javaType="java.lang.Integer"&gt;&lt;/id&gt; &lt;result property="username" column="username" javaType="java.lang.String"&gt;&lt;/result&gt; &lt;result property="password" column="password" javaType="java.lang.String"&gt;&lt;/result&gt; &lt;result property="email" column="email" javaType="java.lang.String"&gt;&lt;/result&gt; &lt;result property="salt" column="salt" javaType="java.lang.Integer"&gt;&lt;/result&gt; &lt;result property="status" column="status" javaType="java.lang.Integer"&gt;&lt;/result&gt; &lt;result property="createdTime" column="created_time" jdbcType="DATE" javaType="java.util.Date"&gt;&lt;/result&gt; &lt;result property="updatedTime" column="updated_time" jdbcType="DATE" javaType="java.util.Date"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;sql id="tableName"&gt;user&lt;/sql&gt; &lt;sql id="insertFields"&gt;username, password, email, salt, status, created_time, updated_time&lt;/sql&gt; &lt;sql id="selectFields"&gt;id, &lt;include refid="insertFields"/&gt;&lt;/sql&gt; &lt;!-- 方法的id必须和UserMapper接口中定义的方法名相同 --&gt; &lt;!-- parameterType必须和传入的参数类型相同，若要传多个参数需要在Mapper接口中加@Param注解 --&gt; &lt;select id="selectByName" parameterType="java.lang.String" resultMap="userMap"&gt; SELECT &lt;include refid="selectFields"/&gt; FROM &lt;include refid="tableName"/&gt; WHERE username = #&#123;username&#125; &lt;/select&gt; &lt;select id="selectByEmail" parameterType="java.lang.String" resultMap="userMap"&gt; SELECT &lt;include refid="selectFields"/&gt; FROM &lt;include refid="tableName"/&gt; WHERE email = #&#123;email&#125; &lt;/select&gt; &lt;insert id="addUser" parameterType="User"&gt; INSERT INTO &lt;include refid="tableName"/&gt; (&lt;include refid="insertFields"/&gt;) VALUES (#&#123;username&#125;, #&#123;password&#125;, #&#123;email&#125;, #&#123;salt&#125;, #&#123;status&#125;, #&#123;createdTime&#125;, #&#123;updatedTime&#125;) &lt;/insert&gt;&lt;/mapper&gt; 编写UserServiceUserService调用UserMapper的方法，并为UserController提供返回值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Servicepublic class UserService &#123; // 利用slf4j生成log信息 private static final Logger logger = LoggerFactory.getLogger(UserService.class); @Autowired private UserMapper userMapper; public User getUserByName(String username) &#123; return userMapper.selectByName(username); &#125; /** * add a new user * * @param username * @param email * @return map * @author wenzhiquan */ public Map&lt;String, Object&gt; addUser(String username, String email) &#123; logger.info("UserService addUser"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (StringUtils.isEmpty(username)) &#123; map.put("msg", "username can not be empty"); return map; &#125; if (userMapper.selectByName(username) != null) &#123; map.put("msg", "username existed"); return map; &#125; if (StringUtils.isEmpty(email)) &#123; map.put("msg", "email can not be empty"); return map; &#125; if (userMapper.selectByEmail(email) != null) &#123; map.put("msg", "email existed"); return map; &#125; // 随机生成一个四位数的盐 int salt = (int)Math.random() * 8999 + 1000; StringBuilder sb = new StringBuilder(); sb.append(MD5Util.md5(username + "123")).append(String.valueOf(salt)); String password = MD5Util.md5(sb.toString()); int status = Constant.Status.NEED_CHANGE_PWD.getIndex(); Date date = new Date(); User user = new User(); user.setUsername(username); user.setPassword(password); user.setEmail(email); user.setSalt(salt); user.setStatus(status); user.setCreatedTime(date); user.setUpdatedTime(date); userMapper.addUser(user); return map; &#125; 其中使用的MD5Util为自己编写的MD5加密算法。 1234567891011121314151617181920212223242526272829303132333435363738394041public class MD5Util &#123; /** * 获取加密后的字符串 * @param pw * @return */ public static String md5(String pw) &#123; try &#123; // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”） MessageDigest messageDigest =MessageDigest.getInstance("MD5"); // 输入的字符串转换成字节数组 byte[] inputByteArray = pw.getBytes(); // inputByteArray是输入字符串转换得到的字节数组 messageDigest.update(inputByteArray); // 转换并返回结果，也是字节数组，包含16个元素 byte[] resultByteArray = messageDigest.digest(); // 字符数组转换成字符串返回 return byteArrayToHex(resultByteArray); &#125; catch (NoSuchAlgorithmException e) &#123; return null; &#125; &#125; public static String byteArrayToHex(byte[] byteArray) &#123; // 首先初始化一个字符数组，用来存放每个16进制字符 char[] hexDigits = &#123;'0','1','2','3','4','5','6','7','8','9', 'A','B','C','D','E','F' &#125;; // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方）） char[] resultCharArray =new char[byteArray.length * 2]; // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去 int index = 0; for (byte b : byteArray) &#123; resultCharArray[index++] = hexDigits[b&gt;&gt;&gt; 4 &amp; 0xf]; resultCharArray[index++] = hexDigits[b&amp; 0xf]; &#125; // 字符数组组合成字符串返回 return new String(resultCharArray); &#125;&#125; Constant为自己编写的常量枚举魔法数 1234567891011121314151617181920212223242526272829303132public class Constant &#123; public enum Status &#123; AVAILABLE("available", 0), UNAVAILABLE("unavailable", 1), NEED_CHANGE_PWD("need change password", 2); public String name; public int index; Status(String name, int index) &#123; this.name = name; this.index = index; &#125; public String getName() &#123; return name; &#125; public int getIndex() &#123; return index; &#125; public static String getNameByIndex(int index) &#123; for (Status c : Status.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; &#125;&#125; 编写UserControllerUserController用于处理用户请求并返回数据。 123456789101112131415161718192021222324252627282930313233343536@Controllerpublic class UserController &#123; private static final Logger logger = LoggerFactory.getLogger(UserController.class); @Autowired private UserService userService; @RequestMapping(path = &#123;"/addUser"&#125;, method = &#123;RequestMethod.GET&#125;) public String addUser(Model model) &#123; // model用于向view层返回数据 model.addAttribute("title", "addUser"); // 返回值为模板所在目录及其名称 return "user/addUser"; &#125; @RequestMapping(path = &#123;"/addUser"&#125;, method = &#123;RequestMethod.POST&#125;) @ResponseBody // 加上此字段后表明返回的数据直接发送给浏览器而不经过模板引擎渲染 public String addUser(@RequestParam("username") String username, @RequestParam("email") String email, HttpServletResponse response) &#123; try &#123; Map&lt;String, Object&gt; map = userService.addUser(username, email); if (map.containsKey("msg")) &#123; return JsonUtil.getJSONString(1, map); &#125; map.put("msg", "success"); return JsonUtil.getJSONString(0, map); &#125; catch (Exception e) &#123; logger.error("add user failed!"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "add user failed."); return JsonUtil.getJSONString(1, map); &#125; &#125;&#125; JsonUtil为自己编写的将数据转换为json字符串的工具类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class JsonUtil &#123; private static final Logger logger = LoggerFactory.getLogger(JsonUtil.class); /** * Generate a json string with certain code * @author wenzhiquan * @param code * @return json String */ public static String getJSONString(int code) &#123; JSONObject json = new JSONObject(); json.put("code", code); return json.toJSONString(); &#125; /** * Generate a json string with code and message * @author wenzhiquan * @param code * @param msg * @return json String */ public static String getJSONString(int code, String msg) &#123; JSONObject json = new JSONObject(); json.put("code", code); json.put("msg", msg); return json.toJSONString(); &#125; /** * Generate a json string with code and map * @author wenzhiquan * @param code * @param map * @return json String */ public static String getJSONString(int code, Map&lt;String, Object&gt; map) &#123; JSONObject json = new JSONObject(); json.put("code", code); for (Map.Entry&lt;String, Object&gt; entry: map.entrySet()) &#123; json.put(entry.getKey(), entry.getValue()); &#125; return json.toJSONString(); &#125;&#125; 编写对应的js请求和前端页面前端页面分为base，nav和sidebar，和页面内容addUser四大部分。 nav: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:replace="~&#123;common/base::common_header(_)&#125;"&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- top navigation --&gt;&lt;div th:fragment="top_nav" class="top_nav"&gt; &lt;div class="nav_menu"&gt; &lt;nav class="" role="navigation"&gt; &lt;div class="nav toggle"&gt; &lt;a id="menu_toggle"&gt;&lt;i class="fa fa-bars"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;ul class="nav navbar-nav navbar-right"&gt; &lt;li class=""&gt; &lt;a href="javascript:;" class="user-profile dropdown-toggle" data-toggle="dropdown" aria-expanded="false"&gt; &lt;img src="images/img.jpg" th:src="@&#123;/statics/img/default.png&#125;" alt=""&gt; &lt;span th:if="$&#123;user&#125;" th:text="$&#123;user.username&#125;"&gt;John Doe&lt;/span&gt; &lt;span class=" fa fa-angle-down"&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class="dropdown-menu dropdown-usermenu pull-right"&gt; &lt;li&gt;&lt;a href="javascript:;"&gt; Profile&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href="javascript:;"&gt; &lt;span class="badge bg-red pull-right"&gt;50%&lt;/span&gt; &lt;span&gt;Settings&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt;&lt;a href="javascript:;"&gt;Help&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="login.html" th:href="@&#123;/logout&#125;"&gt;&lt;i class="fa fa-sign-out pull-right"&gt;&lt;/i&gt; Log Out&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- /top navigation --&gt;&lt;/body&gt;&lt;/html&gt; siderbar: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:replace="~&#123;common/base::common_header(_)&#125;"&gt;&lt;/head&gt;&lt;body&gt;&lt;div th:fragment="sidebar" class="col-md-3 left_col"&gt; &lt;div class="left_col scroll-view"&gt; &lt;div class="navbar nav_title" style="border: 0;"&gt; &lt;a href="index.html" th:href="@&#123;/&#125;" class="site_title"&gt;&lt;i class="fa fa-barcode"&gt;&lt;/i&gt; &lt;span&gt;SMS&lt;/span&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;!-- menu profile quick info --&gt; &lt;div class="profile"&gt; &lt;div class="profile_pic"&gt; &lt;img src="/statics/img/img.jpg" th:src="@&#123;/statics/img/default.png&#125;" alt="..." class="img-circle profile_img"&gt; &lt;/div&gt; &lt;div class="profile_info"&gt; &lt;span&gt;Welcome,&lt;/span&gt; &lt;h2 th:if="$&#123;user&#125;" th:text="$&#123;user.username&#125;"&gt;John Doe&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /menu profile quick info --&gt; &lt;br/&gt; &lt;!-- sidebar menu --&gt; &lt;div id="sidebar-menu" class="main_menu_side hidden-print main_menu"&gt; &lt;div class="menu_section"&gt; &lt;h3&gt;General&lt;/h3&gt; &lt;ul class="nav side-menu"&gt; &lt;li&gt;&lt;a&gt;&lt;i class="fa fa-home"&gt;&lt;/i&gt; Home &lt;span class="fa fa-chevron-down"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="nav child_menu"&gt; &lt;li&gt;&lt;a href="index.html" th:href="@&#123;/&#125;"&gt;Dashboard&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a&gt;&lt;i class="fa fa-edit"&gt;&lt;/i&gt; Authority &lt;span class="fa fa-chevron-down"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="nav child_menu"&gt; &lt;li&gt;&lt;a href="form.html" th:href="@&#123;/addUser&#125;"&gt;Add New User&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- /sidebar menu --&gt; &lt;!-- menu footer buttons --&gt; &lt;div class="sidebar-footer hidden-small"&gt; &lt;a data-toggle="tooltip" data-placement="top" title="Settings"&gt; &lt;span class="glyphicon glyphicon-cog" aria-hidden="true"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a data-toggle="tooltip" data-placement="top" title="FullScreen"&gt; &lt;span class="glyphicon glyphicon-fullscreen" aria-hidden="true"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a data-toggle="tooltip" data-placement="top" title="Lock"&gt; &lt;span class="glyphicon glyphicon-eye-close" aria-hidden="true"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a th:href="@&#123;/logout&#125;" data-toggle="tooltip" data-placement="top" title="Logout"&gt; &lt;span class="glyphicon glyphicon-off" aria-hidden="true"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;!-- /menu footer buttons --&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; base: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:fragment="common_header(links)"&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;!-- Meta, title, CSS, favicons, etc. --&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title th:text="$&#123;title&#125;"&gt;&lt;/title&gt; &lt;!-- Common styles and scripts --&gt; &lt;link rel="stylesheet" th:href="@&#123;/statics/vendors/bootstrap/dist/css/bootstrap.min.css&#125;"&gt; &lt;link rel="stylesheet" th:href="@&#123;/statics/vendors/font-awesome/css/font-awesome.min.css&#125;"&gt; &lt;link rel="stylesheet" th:href="@&#123;/statics/css/custom.min.css&#125;"&gt; &lt;link rel="stylesheet" th:href="@&#123;/statics/css/main.css&#125;"&gt; &lt;!--/* Per-page placeholder for additional links */--&gt; &lt;th:block th:replace="$&#123;links&#125;"/&gt;&lt;/head&gt;&lt;body th:fragment="common_body(content, scripts)" class="nav-md"&gt;&lt;div class="container body"&gt; &lt;div class="main_container"&gt; &lt;div th:replace="~&#123;common/sidebar::sidebar&#125;"&gt;&lt;/div&gt; &lt;div th:replace="~&#123;common/nav::top_nav&#125;"&gt;&lt;/div&gt; &lt;!-- page content --&gt; &lt;div class="right_col" role="main" th:include="$&#123;content&#125;"&gt; &lt;/div&gt; &lt;!-- /page content --&gt; &lt;!-- footer content --&gt; &lt;footer&gt; &lt;div class="pull-right"&gt; ©2017 All Rights Reserved &lt;span class="hidden-xs"&gt;Powered By &lt;a href="http://wenzhiquan.github.io" target="blank"&gt;Wen Zhiquan&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;/footer&gt; &lt;!-- /footer content --&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="../vendors/jquery/dist/jquery.min.js" th:src="@&#123;/statics/vendors/jquery/dist/jquery.min.js&#125;"&gt;&lt;/script&gt;&lt;!-- Bootstrap --&gt;&lt;script src="../vendors/bootstrap/dist/js/bootstrap.min.js" th:src="@&#123;/statics/vendors/bootstrap/dist/js/bootstrap.min.js&#125;"&gt;&lt;/script&gt;&lt;!-- Custom Theme Scripts --&gt;&lt;script src="../build/js/custom.min.js" th:src="@&#123;/statics/js/custom.js&#125;"&gt;&lt;/script&gt;&lt;!--/* Per-page placeholder for additional links */--&gt;&lt;th:block th:replace="$&#123;scripts&#125;"/&gt;&lt;/body&gt;&lt;/html&gt; addUser: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:replace="~&#123;common/base::common_header(~&#123;::link&#125;)&#125;"&gt; &lt;!-- iCheck --&gt; &lt;link href="../vendors/iCheck/skins/flat/green.css" th:href="@&#123;/statics/vendors/iCheck/skins/flat/green.css&#125;" rel="stylesheet"&gt; &lt;!-- bootstrap-wysiwyg --&gt; &lt;link href="../vendors/google-code-prettify/bin/prettify.min.css" th:href="@&#123;/statics/vendors/google-code-prettify/bin/prettify.min.css&#125;" rel="stylesheet"&gt; &lt;!-- Select2 --&gt; &lt;link href="../vendors/select2/dist/css/select2.min.css" th:href="@&#123;/statics/vendors/select2/dist/css/select2.min.css&#125;" rel="stylesheet"&gt; &lt;!-- Switchery --&gt; &lt;link href="../vendors/switchery/dist/switchery.min.css" th:href="@&#123;/statics/vendors/switchery/dist/switchery.min.css&#125;" rel="stylesheet"&gt; &lt;!-- starrr --&gt; &lt;link href="../vendors/starrr/dist/starrr.css" th:href="@&#123;/statics/vendors/starrr/dist/starrr.css&#125;" rel="stylesheet"&gt;&lt;/head&gt;&lt;body th:replace="~&#123;common/base::common_body(~&#123;::content&#125;, ~&#123;::script&#125;)&#125;"&gt;&lt;div th:fragment="content"&gt; &lt;div class=""&gt; &lt;div class="alert alert-info"&gt; &lt;/div&gt; &lt;div class="page-title"&gt; &lt;div class="title_left"&gt; &lt;h3&gt;Add new user&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;div class="row"&gt; &lt;div class="col-md-12 col-sm-12 col-xs-12"&gt; &lt;div class="x_panel"&gt; &lt;div class="x_content"&gt; &lt;br/&gt; &lt;form id="add-user-form" data-parsley-validate class="form-horizontal form-label-left"&gt; &lt;div class="item form-group"&gt; &lt;label class="control-label col-md-3 col-sm-3 col-xs-12" for="username"&gt;Username &lt;span class="required"&gt;*&lt;/span&gt; &lt;/label&gt; &lt;div class="col-md-6 col-sm-6 col-xs-12"&gt; &lt;input id="username" class="form-control col-md-7 col-xs-12" name="username" placeholder="Enter the username" required="required" type="text"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item form-group"&gt; &lt;label class="control-label col-md-3 col-sm-3 col-xs-12" for="email"&gt;Email &lt;span class="required"&gt;*&lt;/span&gt; &lt;/label&gt; &lt;div class="col-md-6 col-sm-6 col-xs-12"&gt; &lt;input type="email" id="email" name="email" placeholder="Enter the email" required="required" class="form-control col-md-7 col-xs-12"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ln_solid"&gt;&lt;/div&gt; &lt;div class="form-group"&gt; &lt;div class="col-md-6 col-sm-6 col-xs-12 col-md-offset-3"&gt; &lt;button type="reset" id="clear-btn" class="btn btn-primary"&gt;Clear&lt;/button&gt; &lt;button type="submit" id="submit-btn" class="btn btn-success"&gt;Submit&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div th:fragment="script"&gt; &lt;!-- validator --&gt; &lt;script src="../vendors/validator/validator.min.js" th:src="@&#123;/statics/vendors/validator/validator.min.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/statics/js/authority/addUser.js&#125;"&gt;&lt;/script&gt; &lt;script th:src="@&#123;/statics/vendors/layer/layer.js&#125;"&gt;&lt;/script&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; addUser.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * Created by wenzhiquan on 16/7/14. */$(function () &#123; var username = $("#username"), email = $("#email"), clearBtn = $("#clear-btn"), submitBtn = $("#submit-btn"); // initialize the validator function validator.message.date = 'not a real date'; // validate a field on "blur" event, a 'select' on 'change' event &amp; a '.reuired' classed multifield on 'keyup': $('form') .on('blur', 'input[required], input.optional, select.required', validator.checkField) .on('change', 'select.required', validator.checkField); $('.multi.required').on('keyup blur', 'input', function () &#123; validator.checkField.apply($(this).siblings().last()[0]); &#125;); submitBtn.click(function (e) &#123; e.preventDefault(); var submit = true; // evaluate the form using generic validating if (!validator.checkAll($('form'))) &#123; submit = false; &#125; console.log(submit); if (submit) &#123; $.ajax(&#123; url: 'addUser',// 跳转到 action data: &#123; username: username.val(), email: email.val(), &#125;, type: 'post', cache: false, dataType: 'json', success: function (data) &#123; if (data.code == 0) &#123; layer.msg('Success!', &#123; icon: 1, time: 1000 //1s后自动关闭 &#125;); &#125; else &#123; layer.msg('Failed!', &#123; icon: 2, time: 1000 //1s后自动关闭 &#125;); &#125; &#125;, error: function () &#123; layer.msg('Error!', &#123; time: 1000 //1s后自动关闭 &#125;); &#125; &#125;); &#125; return false; &#125;); clearBtn.click(function () &#123; username.val(""); email.val(""); &#125;);&#125;); 运行效果 用户登录功能因为已经添加过User表并完成了model和mapper的编写，用户登录功能分为以下几个步骤进行完成： 添加Token数据库表及对应model和mapper 编写对应的service 编写对应的controller 编写对应的js请求和前端页面 编写登录拦截器 添加Token数据库表及Token model和TokenMapper由于需要保持用户的登录状态，并且不能把用户信息保存在浏览器中，故需要在服务器端增加一个token字段，作为识别用户的唯一信息，可以保证用户登录时不用再次输入用户名密码。 首先，需要在数据库中增加Token表，用于存储token信息： 12345678CREATE TABLE `token` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'token id', `user_id` int(11) NOT NULL COMMENT 'user id', `token` varchar(32) NOT NULL COMMENT 'token content', `expired_time` datetime NOT NULL COMMENT 'token expired time', `status` int(4) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8; 表中的status字段用于指示该token是否可用。 接着，类似于User类，需要生成一个Token的实体类： 12345678public class Token &#123; private int id; private int userId; private String token; private Date expiredTime; private int status; // 需要生成所有属性的get和set方法。 类似的，需要编写TokenMapper文件和相应的xml文件： 123456789@Repositorypublic interface TokenMapper &#123; Token selectByToken(String token); int addToken(Token token); int updateStatus(@Param("status")int status, @Param("token")String token);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org/DTD Mapper 3.0" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="cn.edu.bupt.wen.mapper.TokenMapper"&gt; &lt;!-- 自定义返回结果集 --&gt; &lt;resultMap id="tokenMap" type="Token"&gt; &lt;id property="id" column="id" javaType="java.lang.Integer"&gt;&lt;/id&gt; &lt;result property="userId" column="user_id" javaType="java.lang.Integer"&gt;&lt;/result&gt; &lt;result property="token" column="token" javaType="java.lang.String"&gt;&lt;/result&gt; &lt;result property="status" column="status" javaType="java.lang.Integer"&gt;&lt;/result&gt; &lt;result property="expiredTime" column="expired_time" jdbcType="DATE" javaType="java.util.Date"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;sql id="tableName"&gt;token&lt;/sql&gt; &lt;sql id="insertFields"&gt;user_id, token, expired_time, status&lt;/sql&gt; &lt;sql id="selectFields"&gt;id, &lt;include refid="insertFields"&gt;&lt;/include&gt;&lt;/sql&gt; &lt;select id="selectByToken" parameterType="java.lang.String" resultMap="tokenMap"&gt; SELECT &lt;include refid="selectFields"&gt;&lt;/include&gt; FROM &lt;include refid="tableName"&gt;&lt;/include&gt; WHERE token = #&#123;token&#125; &lt;/select&gt; &lt;insert id="addToken" parameterType="Token"&gt; INSERT INTO &lt;include refid="tableName"&gt;&lt;/include&gt; (&lt;include refid="insertFields"&gt;&lt;/include&gt;) VALUES (#&#123;userId&#125;, #&#123;token&#125;, #&#123;expiredTime&#125;, #&#123;status&#125;) &lt;/insert&gt; &lt;update id="updateStatus"&gt; UPDATE &lt;include refid="tableName"&gt;&lt;/include&gt; SET status = #&#123;status&#125; WHERE token = #&#123;token&#125; &lt;/update&gt;&lt;/mapper&gt; 至此，Token相关内容基本完成。 编写UserService类登录和登出是一对必不可少的操作。故为UserService类增加login和logout方法，除此之外，需要保存用户登录状态，故需要增加生成token字段的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * settle the login request * * @param username * @param password * @return map * @author wenzhiquan */ public Map&lt;String, Object&gt; login(String username, String password) &#123; logger.info("UserService login"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); logger.info(username); if (StringUtils.isEmpty(username)) &#123; map.put("msg", "username can not be empty"); return map; &#125; if (StringUtils.isEmpty(password)) &#123; map.put("msg", "password can not be empty"); return map; &#125; User user = userMapper.selectByName(username); if (user == null) &#123; map.put("msg", "username does not exist"); return map; &#125; logger.info(user.getUsername()); StringBuffer stringBuffer = new StringBuffer(); stringBuffer.append(MD5Util.md5(password)).append(user.getSalt()); if (!user.getPassword().equals(MD5Util.md5(stringBuffer.toString()))) &#123; map.put("msg", "wrong password"); return map; &#125; String token = generateToken(user.getId()); map.put("token", token); return map; &#125; /** * generate login token * * @param userId * @return token * @author wenzhiquan */ public String generateToken(int userId) &#123; Token token = new Token(); token.setUserId(userId); Date date = new Date(); date.setTime(date.getTime() + 1000 * 3600 * 24); token.setExpiredTime(date); token.setToken(UUID.randomUUID().toString().replaceAll("-", "")); token.setStatus(0); tokenMapper.addToken(token); return token.getToken(); &#125; /** * logout and set token status to 1 * * @param token * @return * @author wenzhiquan */ public void logout(String token) &#123; tokenMapper.updateStatus(1, token); &#125; 编写UserController类同样的，需要在UserController类中增加登录登出相关代码： 12345678910111213141516171819202122232425262728293031323334@RequestMapping(path = &#123;"/login"&#125;, method = &#123;RequestMethod.GET&#125;)public String login(Model model) &#123; model.addAttribute("title", "Login"); return "user/login";&#125;@RequestMapping(path = &#123;"/login"&#125;, method = &#123;RequestMethod.POST&#125;)@ResponseBodypublic String login(@RequestParam("username") String username, @RequestParam("password") String password, HttpServletResponse response) &#123; logger.info(username); try &#123; Map&lt;String, Object&gt; map = userService.login(username, password); if (map.containsKey("token")) &#123; Cookie cookie = new Cookie("token", map.get("token").toString()); cookie.setPath("/"); response.addCookie(cookie); map.put("msg", "login successful!"); &#125; return JsonUtil.getJSONString(0, map); &#125; catch (Exception e) &#123; logger.error("login failed!"); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("msg", "login failed"); return JsonUtil.getJSONString(1, map); &#125;&#125;@RequestMapping(path = &#123;"/logout"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;)public String logout(@CookieValue("token") String token) &#123; userService.logout(token); return "redirect:/login";&#125; 在获取了用户的token之后，需要将token存储到浏览器的Cookie中，以便下次访问时将token发送给服务器，用于查询用户信息。 编写对应的js请求和前端页面登录界面独立于其他界面存在，便于拦截请求后的页面跳转。 login.html: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en" xmlns:th="http://www.thymeleaf.org"&gt;&lt;head th:replace="~&#123;common/base::common_header(~&#123;::link&#125;)&#125;"&gt; &lt;link rel="stylesheet" th:href="@&#123;/statics/vendors/animate.css/animate.min.css&#125;"&gt;&lt;/head&gt;&lt;body class="login"&gt;&lt;div&gt; &lt;a class="hiddenanchor" id="signin"&gt;&lt;/a&gt; &lt;div class="login_wrapper"&gt; &lt;div class="animate form login_form"&gt; &lt;section class="login_content"&gt; &lt;form&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;div&gt; &lt;input type="text" class="form-control" id="username" name="username" placeholder="Username" required="required"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type="password" class="form-control" id="password" name="password" placeholder="Password" required="required"/&gt; &lt;/div&gt; &lt;div class="error" id="error-password"&gt;&lt;/div&gt; &lt;div class="error" id="error-username"&gt;&lt;/div&gt; &lt;div&gt; &lt;a class="btn btn-default submit" id="login-btn"&gt;Log in&lt;/a&gt; &lt;a class="reset_pass"&gt;Lost your password?&lt;/a&gt; &lt;/div&gt; &lt;div class="clearfix"&gt;&lt;/div&gt; &lt;div class="separator"&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt; &lt;h1&gt;&lt;i class="fa fa-barcode"&gt;&lt;/i&gt; SMS&lt;/h1&gt; ©2017 All Rights Reserved &lt;span class="hidden-xs"&gt;Powered By &lt;a href="http://wenzhiquan.github.io" target="blank"&gt;Wen Zhiquan&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/section&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- jQuery --&gt;&lt;script src="../vendors/jquery/dist/jquery.min.js" th:src="@&#123;/statics/vendors/jquery/dist/jquery.min.js&#125;"&gt;&lt;/script&gt;&lt;!-- Bootstrap --&gt;&lt;script src="../vendors/bootstrap/dist/js/bootstrap.min.js" th:src="@&#123;/statics/vendors/bootstrap/dist/js/bootstrap.min.js&#125;"&gt;&lt;/script&gt;&lt;script th:src="@&#123;/statics/js/login.js&#125;"&gt;&lt;/script&gt;&lt;script th:src="@&#123;/statics/vendors/layer/layer.js&#125;"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; login.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465$(function () &#123; var username = $("#username"), password = $("#password"), loginBtn = $("#login-btn"), errorUsername = $("#error-username"), errorPassword = $("#error-password"); username.blur(function () &#123; if (username.val() == "") &#123; errorUsername.html("username can not be empty"); errorUsername.show(); &#125; &#125;); username.focus(function () &#123; errorUsername.hide(); username.val(""); &#125;); password.blur(function () &#123; if (password.val() == "") &#123; errorPassword.html("password can not be empty"); errorPassword.show(); &#125; &#125;); password.focus(function () &#123; errorPassword.hide(); password.val(""); &#125;); loginBtn.click(function () &#123; console.log(username.val()); if (username.val() != "" &amp;&amp; password.val() != "") &#123; $.ajax(&#123; url: 'login',// 跳转到 action data: &#123; username: username.val(), password: password.val() &#125;, type: 'post', cache: false, dataType: 'json', success: function (data) &#123; if (data.code == 0) &#123; if (data.next != undefined) &#123; location.href = data.next; &#125; location.href = "/"; &#125; else &#123; layer.msg(data.msg, &#123; time: 1000 //1s后自动关闭 &#125;); &#125; &#125;, error: function () &#123; layer.msg('Error!', &#123; time: 1000 //1s后自动关闭 &#125;); &#125; &#125;); &#125; &#125;);&#125;); 编写登录拦截器拦截器分为两个，一个用于读取token信息，并根据token信息写入用户信息，一个用于拦截未登录用户。 拦截器运行阶段如下： PassportInterceptor（主要用于读取token，并根据此token读取并写入用户信息）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Componentpublic class PassportInterceptor implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(PassportInterceptor.class); @Autowired private TokenMapper tokenMapper; @Autowired private UserMapper userMapper; @Autowired private HostHolder hostHolder; /* * 此阶段发生在Controller运行之前 */ @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; String token = null; if (httpServletRequest.getCookies() != null) &#123; for (Cookie cookie : httpServletRequest.getCookies()) &#123; if (cookie.getName().equals("token")) &#123; token = cookie.getValue(); break; &#125; &#125; &#125; if (token != null) &#123; Token selectedToken = tokenMapper.selectByToken(token); if (selectedToken == null || selectedToken.getExpiredTime().before(new Date()) || selectedToken.getStatus() != 0) &#123; return true; &#125; User user = userMapper.selectById(selectedToken.getUserId()); hostHolder.setUser(user); &#125; return true; &#125; /* * 此阶段发生在Controller运行之后 */ @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; if (modelAndView != null &amp;&amp; hostHolder.getUser() != null) &#123; modelAndView.addObject("user", hostHolder.getUser()); &#125; &#125; /* * 此阶段发生在视图渲染完成之后 */ @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; hostHolder.clear(); &#125;&#125; LoginRequiredInterceptor(用于拦截未登录用户): 1234567891011121314151617181920212223@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; if (hostHolder.getUser() == null) &#123; httpServletResponse.sendRedirect("/login"); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 拦截器编写完成后，需要将拦截器注册到Spring当中： spring-interceptor.xml: 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;mvc:interceptors&gt; &lt;!-- 使用bean定义一个Interceptor，直接定义在mvc:interceptors根下面的Interceptor将拦截所有的请求 --&gt; &lt;bean class="cn.edu.bupt.wen.interceptor.PassportInterceptor"/&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/*"/&gt; &lt;mvc:exclude-mapping path="/login"/&gt; &lt;!-- 定义在mvc:interceptor下面的表示是对特定的请求才进行拦截的 --&gt; &lt;bean class="cn.edu.bupt.wen.interceptor.LoginRequiredInterceptor"/&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;&lt;/beans&gt; 并在spring-mvc.xml中加入引用&lt;import resource=&quot;spring-interceptor.xml&quot;&gt;&lt;/import&gt; 运行效果 遇到的问题和解决方案123456789101112131415161718192021问题：无法找到*Mapper.xml文件解决方案：*Mapper.xml文件应当位于resources文件夹中而不是java文件夹中问题：IDEA提示无法注入mapper的bean解决方案：将Mapper接口文件注解为@Repository问题：Could not resolve placeholder解决方案：在引入外部文件的bean中增加属性&lt;property name="ignoreUnresolvablePlaceholders" value="true" /&gt;并且需要注意properties的格式必须是beanName.property=value 问题：xml文件，元素 'bean' 必须不含字符 [子级]解决方案：xml文件中有不合法字符，可能是中文没有注释掉问题：使用AOP的通配符时，报Expected raw type form oforg.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry错误解决方案：AspectJ 1.8.10版本bug，换成1.8.9版本问题解决问题：数据库datetime类型无法直接映射到java项目中解决方案：在Mapper.xml文件中增加resultMap进行java.util.Date类型的映射]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA和gradle创建超市管理系统（壹）-- 环境配置]]></title>
    <url>%2F2017%2F01%2F01%2F2017-01-01-idea-gradle-tssm-supermarket-manage-system-1%2F</url>
    <content type="text"><![CDATA[“IDEA是jetbrains公司开发的Java开发IDE，功能齐全。使用IDEA搭建SSM开发环境简单有效。本项目基于Spring，Spring MVC和MyBatis进行开发，模板引擎为Thymeleaf。” 概述Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建Web应用程序的全功能MVC模块。 MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 准备工作1.安装mysql，并完成相应数据库的建立 2.安装IDEA完整版或社区版 3.下载tomcat或其他服务器 创建工程打开IDEA软件，选择Create New Project： 选择创建基于gradle的java web项目： 输入GroupId和ArtifactId： 选择gradle的来源，可以用自己下载的gradle，也可以使用IDEA内建的gradle版本： 选择项目的目录： 点击完成，会生成一个最基本的java web目录，增加文件夹和相应文件，将其目录结构改为以下结构： 其中resources目录中的config文件夹中的文件和WEB-INF文件夹下的web.xml，以及build.gradle都是自己进行配置的。 配置文件spring-mvc.xml123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="cn.edu.bupt.wen"/&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!--静态文件访问权限配置--&gt; &lt;mvc:resources mapping="statics/**" location="/WEB-INF/statics/"/&gt; &lt;!-- 启用aop --&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;import resource="spring-mybatis.xml"&gt;&lt;/import&gt; &lt;import resource="spring-thymeleaf.xml"&gt;&lt;/import&gt;&lt;/beans&gt; jdbc-mysql.properties12345678910# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/wenzhiquan/.gradle/caches/modules-2/files-2.1/mysql\/mysql-connector-java/5.1.40/ef2a2ceab1735eaaae0b5d1cccf574fb7c6e1c52/\mysql-connector-java-5.1.40.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/nowcoder?\useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.username=rootjdbc.password=root spring-mybatis.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 引入外部数据源配置信息 --&gt; &lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:config/mybatis/jdbc-mysql.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true" /&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Session工厂 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--&amp;lt;!&amp;ndash; 加载mybatis-config.xml文件 &amp;ndash;&amp;gt;--&gt; &lt;!--&lt;property name="configLocation" value="classpath:config/mybatis/mybatis-config.xml"&gt;&lt;/property&gt;--&gt; &lt;!--自动扫描需要定义类别名的包，将包内的JAVA类的类名作为类别名--&gt; &lt;property name="typeAliasesPackage" value="cn.edu.bupt.wen.model"&gt;&lt;/property&gt; &lt;!-- 指定实体类映射文件，可以指定同时指定某一包以及子包下面的所有配置文件 --&gt; &lt;property name="mapperLocations" value="classpath:sqlMapper/*.xml"/&gt; &lt;/bean&gt; &lt;!-- 自动扫描所有的Mapper接口与文件 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.edu.bupt.wen.mapper"&gt;&lt;/property&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 实体类,简称 -设置别名 --&gt; &lt;typeAliases&gt; &lt;typeAlias alias="User" type="cn.edu.bupt.wen.model.User" /&gt; &lt;/typeAliases&gt; &lt;!-- 实体接口映射资源 --&gt; &lt;mappers&gt; &lt;mapper resource="sqlMapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 注：在spring-mybatis.xml文件中配置session工厂时，如果配置了configLocation这一个property的话，需要指定mybatis配置文件的位置，如果配置了typeAliasesPackage和mapperLocations这两个property的话，就不再需要配置configLocation这个property了。 spring-thymeleaf.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- Thymeleaf View Resolver - implementation of Spring's ViewResolver interface --&gt; &lt;bean id="viewResolver" class="org.thymeleaf.spring4.view.ThymeleafViewResolver"&gt; &lt;property name="templateEngine" ref="templateEngine" /&gt; &lt;!-- 解决中文乱码问题 template resolver中需要同时加上这个参数 --&gt; &lt;property name="characterEncoding" value="UTF-8" /&gt; &lt;/bean&gt; &lt;!-- Thymeleaf Template Engine (Spring4-specific version) --&gt; &lt;bean id="templateEngine" class="org.thymeleaf.spring4.SpringTemplateEngine"&gt; &lt;property name="templateResolvers"&gt; &lt;set&gt; &lt;ref bean="templateResolver" /&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Thymeleaf Template Resolver --&gt; &lt;bean id="templateResolver" class="org.thymeleaf.spring4.templateresolver.SpringResourceTemplateResolver"&gt; &lt;property name="prefix" value="/WEB-INF/templates/" /&gt; &lt;property name="suffix" value=".html"/&gt; &lt;property name="templateMode" value="HTML" /&gt; &lt;!--解决中文乱码问题--&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt; &lt;/bean&gt;&lt;/beans&gt; web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; build.gradle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364group 'cn.edu.bupt.wen'version '1.0-SNAPSHOT'apply plugin: 'groovy'apply plugin: 'java'apply plugin: 'war'apply plugin: 'idea'sourceCompatibility = 1.8buildscript &#123; repositories &#123; jcenter &#123; url "http://jcenter.bintray.com/" &#125; &#125;&#125;allprojects &#123; repositories &#123; jcenter &#123; url "http://jcenter.bintray.com/" &#125; &#125;&#125;// 配置gradle的依赖项dependencies &#123; compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.4.7' compile group: 'javax.servlet', name: 'jstl', version: '1.2' // Slf4j compile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.22' compile group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.22' //fastJson compile group: 'com.alibaba', name: 'fastjson', version: '1.2.23' //apache common lang compile group: 'org.apache.commons', name: 'commons-lang3', version: '3.5' //java servlet api compile group: 'javax.servlet', name: 'javax.servlet-api', version: '4.0.0-b01' // thymeleaf compile group: 'org.thymeleaf', name: 'thymeleaf', version: '3.0.2.RELEASE' compile group: 'org.thymeleaf', name: 'thymeleaf-spring4', version: '3.0.2.RELEASE' // Aspectj compile group: 'org.aspectj', name: 'aspectjrt', version: '1.8.9' compile group: 'org.aspectj', name: 'aspectjweaver', version: '1.8.9' compile group: 'org.aspectj', name: 'aspectjtools', version: '1.8.9' // Spring compile group: 'org.springframework', name: 'spring-core', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-web', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-webmvc', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-jdbc', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-aop', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-context', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-beans', version: '4.3.4.RELEASE' compile group: 'org.springframework', name: 'spring-test', version: '4.3.4.RELEASE' // MyBatis compile group: 'org.mybatis', name: 'mybatis', version: '3.4.1' compile group: 'org.mybatis', name: 'mybatis-spring', version: '1.3.0' compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.40' // junit compile group: 'junit', name: 'junit', version: '4.12' testCompile group: 'junit', name: 'junit', version: '4.12'&#125; 下载gradle依赖包至此，基本的配置就完成了，接下来就需要运行gradle下载相应的依赖包了，操作如下：打开IDEA &gt; View &gt; Tool Windows &gt; gradle: 点击图中的按钮，IDEA就会自动下载依赖包了。 下载完成后，目录下的External Libraries文件夹会生成相应的目录： 下载完依赖包之后，整体的配置基本上就完成了。 部署到Tomcat服务器打开IDEA &gt; Run &gt; Edit Configurations... 点击tomcat server的local选项，点击右上角的configure...，在弹出的对话框中选中下载的Tomcat根目录： 然后将配置好的tomcat添加到运行库当中： 然后在Deployment选项卡中添加项目即可： 编写代码并运行编写controller代码在controller文件夹中创建IndexController文件，将代码修改为： 1234567891011121314151617181920package cn.edu.bupt.wen.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;/** * Author wenzhiquan * Created on 16/4/12 下午12:25 * File name: IndexController.java * Description: null */@Controllerpublic class IndexController &#123; @RequestMapping(path = &#123;"/", "/index"&#125;, method = &#123;RequestMethod.GET&#125;) public String index()&#123; return "index"; &#125;&#125; 修改index.html将index.html文件修改为自己想要的样式： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; Hello World!&lt;/body&gt;&lt;/html&gt; 运行Tomcat 点击运行按钮，服务器启动后会自动启动浏览器进入主界面： 至此，hello world程序已经完成。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Java</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sed流编辑器]]></title>
    <url>%2F2016%2F10%2F15%2F2016-10-15-sed%2F</url>
    <content type="text"><![CDATA[“sed是用于过滤和转换文本的流编辑器。” 概述sed，全称为stream editor，是一个非交互式的编辑器。 sed命令是利用script来处理文本文件。sed可依照script的指令，来处理、编辑文本文件。 sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 sed基本知识点sed工作流程 前提：待操作文本是由至上而下的一行或N行组成。 基本工作流程： 当用sed命令对文本进行处理的时候，sed先读取对象的文本文件的第一行到模式空间中。 当有内容进入模式空间时，sed的编辑命令对模式空间中的内容进行编辑操作（修改，替换，删除，追加，显示等等） 模式空间中的内容编辑处理完成之后，sed把此内容通过标准输出（默认为显示器）打印出来，并删除模式空间中的内容。 第一行处理结束。从新读取第二行的内容进行处理，直到最后一行。 注意：持有空间可以和模式空间的内容进行互相追加、覆盖等操作。 sed命令执行位置几乎所有的sed命令都可以添加[address[,address]]来确定命令执行的位置，完整指令如下： 123456# !表示匹配成功后是否执行命令[address[,address]][!]&#123;cmd&#125;# 删除非第二行至尾行，即删除第一行echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "2,$ ! d"# 删除第二行至尾行echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "2,$ d" 命令执行位置可以使用相对位置： 12345# 匹配a并输出a和其后连续两行，+2表示其后连续两行echo "a\nb\nc\nd\ne\nf" | sed -n "/a/,+2 p"# 匹配a并输出其后连续两行echo "a\nb\nc\nd\ne\nf" | sed -n "/a/,+2&#123;//n;p&#125;"echo "a\nb\nc\nd\ne\nf" | sed -n "/a/,+2&#123;/a/n;p&#125;" sed命令打包sed命令可以用大括号进行分组作为嵌套命令，表示外层命令执行完成后，再执行内层命令： 123456# 对3行到第4行，执行命令/I am/dsed '3,4 &#123;/I am/d&#125;' test# 对1行到第4行，匹配/I am/成功后，再匹配/dog/，成功后执行d命令sed '3,6 &#123;/I am/&#123;/dog/d&#125;&#125;' test# 从第一行到最后一行，如果匹配到空格，则去除空格sed '1,$&#123;s/ *//g&#125;' test 持有空间持有空间（Hold Space），可以存放模式空间中的内容，也可以取出内容追加或覆盖到模式空间中。 常用命令参数如下： 参数 说明 g 将hold space中的内容拷贝到pattern space中，原来pattern space里的内容清除 G 将hold space中的内容append到pattern space后 h 将pattern space中的内容拷贝到hold space中，原来的hold space里的内容被清除 H 将pattern space中的内容append到hold space后 x 交换pattern space和hold space的内容 示例如下： 1234# 将模式空间内容追加到持有空间中echo "one\ntwo\nthree" | sed "H;g"# 若只想看到结果，使用以下命令echo "one\ntwo\nthree" | sed -n "H;p" 具体过程如下： 12# 将文件进行反序echo "one\ntwo\nthree" | sed '1!G;h;$!d' 其中的 ‘1!G;h;$!d’ 可拆解为三个命令： 1!G —— 只有第一行不执行G命令，将hold space中的内容append回到pattern space h —— 每一行都执行h命令，将pattern space中的内容拷贝到hold space中 $!d —— 除了最后一行不执行d命令，其它行都执行d命令，删除当前行 具体过程如下： sed命令常用参数介绍sed命令的语法为：sed [参数]... [执行命令] [输入文件]... 1sed -i "1s/Hello/World/" test 常用参数如下： 参数 说明 -n 安静模式，只打印受影响的行，默认打印输入数据的全部内容 -e script 用于在脚本中添加多个执行命令一次执行，在命令行中执行多个命令通常不需要加该参数 -f filename 指定执行filename文件中的命令 -r 使用扩展正则表达式，默认为标准正则表达式 -i 将直接修改输入文件内容，而不是打印到标准输出设备 sed编辑器的执行命令sed的执行命令格式如下： 12[n1][,n2]command[n1][~step]command 123# 具体命令如下：sed -n '2,5p' test # 打印2到5行sed -n '1~2p' test # 打印奇数行 其中n1，n2表示输入内容的行号，它们之间为,逗号则表示从n1到n2行，如果为～波浪号则表示从n1开始以step为步进的所有行；command为执行动作，下面为一些常用动作指令： 命令 说明 s 行内替换 c 整行替换 a 插入到指定行的后面 i 插入到指定行的前面 p 打印指定行，通常与-n参数配合使用 d 删除指定行 g 一行上替换所有匹配 操作实例 打印指定行 12sed -n '1,6p' test # 打印1到6行sed -n '2~2p' test # 打印偶数行 行内替换 12# 将所有wen替换为hised -n "s/wen/hi/gp" test 行间替换 12# 将第五行替换为wonderfulsed "5c\wonderful" test 行首插入字符 12# 在每行头部插入#+空格sed 's/^/# /g' test 行尾插入字符 12# 在每行行末插入空格+!sed 's/$/ !/g' test 行间插入字符 123456# 在第一行之前插入helloecho "a\naa\naab\naaab\naaabb\naaabbb" | sed "1 i hello"# 在第一行之后插入helloecho "a\naa\naab\naaab\naaabb\naaabbb" | sed "1 a hello"# 在匹配到的aaa之后插入helloecho "a\naa\naab\naaab\naaabb\naaabbb" | sed "/aaa/a hello" 指定替换内容 将数字n放在脚本头部表示匹配第n行： 123456# 替换第3行的所有aecho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "3s/a/A/g"# 替换第3到6行的所有aecho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "3,6s/a/A/g"# 替换奇数行的所有aecho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "1~2s/a/A/g" 将数字n放在脚本尾部表示匹配每行的第n个字符： 123456# 替换每一行的第2个secho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "s/a/A/1"# 替换每一行的第3个secho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "s/a/A/3"# 替换每一行的第2个之后secho "a\naa\naaa\naaaa\naaaaa\naaaaaa\n" | sed "s/a/A/g2" 多个匹配 如果需要一次性匹配多个模式，可使用命令： 123echo "a\naa\naaa\naaaa\naaaaa\naaaaaa" | sed "1,3 s/a/A/g; 4,$ s/a/B/g"# 上面的命令等价于：echo "a\naa\naaa\naaaa\naaaaa\naaaaaa" | sed -e "1,3 s/a/A/g" -e "4,$ s/a/B/g" 注意： 4,$ s/A/B/g两个命令之间是有空格的。 使用匹配的变量 1234# 每个aaa都用中括号圈起来echo "a\naa\naaa\naaaa\naaaaa\naaaaaa" | sed "s/aaa/[&amp;]/g"# 复制每一个aecho "a\naa\naaa\naaaa\naaaaa\naaaaaa" | sed "s/a/&amp;&amp;/g" 圆括号匹配 12# 匹配到aaa+任意字符串则将整个字符串划分为aa:a+任意字符串，\1表示匹配第一个括号的内容，\2同理echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "s/\(aa\)\(a.*\)/\1:\2/g" 删除行 123456# 删除匹配aa的行echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "/aa/d"# 删除第二行echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "2d"# 删除第二行到尾行echo "a\naa\naab\naaab\naaabb\naaabbb" | sed "2,$ d" sed的命令还有很多丰富的使用方法，可以参见官方手册]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Sed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[grep模式匹配命令]]></title>
    <url>%2F2016%2F09%2F06%2F2016-09-06-grep%2F</url>
    <content type="text"><![CDATA[“grep是一种强大的文本搜索工具。” 概述grep全称Globally search a Regular Expression and Print是一种强大的文本搜索工具。它能使用正则表达式搜索文本，并把匹配的行打印出来。 grep的工作方式是在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。grep命令中允许指定的串语句是一个规则表达式，这是一种允许使用某些特殊键盘字符的指定字符串的方法，这种方法中的特殊键盘字符可以用于代表其他字符也可以进一步定义模式匹配工作方式。 基本操作grep命令用于打印输出文本中匹配的模式串，它使用正则表达式作为模式匹配的条件。grep支持三种正则表达式引擎，分别用三个参数指定： 参数 说明 -E POSIX扩展正则表达式，ERE -G POSIX基本正则表达式，BRE -P Perl正则表达式，PCRE 在没学过perl语言的大多数情况下你将只会使用到ERE和BRE。 先介绍一下grep命令的常用参数： 参数 说明 -b 将二进制文件作为文本来进行匹配 -c 统计以模式匹配的数目 -i 忽略大小写 -n 显示匹配文本所在行的行号 -v 反选，输出不匹配行的内容 -r 递归匹配查找 -A n n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行 -B n n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行 --color=auto 将输出中的匹配项设置为自动颜色显示 注：在大多数发行版中是默认设置了grep的颜色的，你可以通过参数指定或修改GREP_COLOR环境变量。 使用正则表达式使用基本正则表达式，BRE 位置 查找test文件中以wen开头的行 12grep 'wen' testgrep '^wen' test 数量 123456# 将匹配以'h'开头以'o'结尾的所有字符串echo 'hello\nho\nhio' | grep 'h.*o'# 将匹配以'h'开头以'o'结尾，中间包含一个任意字符的字符串echo 'hello\nho\nhio' | grep 'h.o'# 将匹配以'h'开头,以任意多个'o'结尾的字符串echo 'hello\nho\nhio' | grep 'ho*' 选择 1234567891011121314# grep默认是区分大小写的，这里将匹配所有的小写字母echo '1234\nabcd\nABCD' | grep '[a-z]'# 将匹配所有的数字echo '1234\nabcd\nABCD' | grep '[0-9]'# 将匹配所有的数字echo '1234\nabcd\nABCD' | grep '[[:digit:]]'# 将匹配所有的小写字母echo '1234\nabcd\nABCD' | grep '[[:lower:]]'# 将匹配所有的大写字母echo '1234\nabcd\nABCD' | grep '[[:upper:]]'# 将匹配所有的字母和数字，包括0-9,a-z,A-Zecho '1234\nabcd\nABCD' | grep '[[:alnum:]]'# 将匹配所有的字母echo '1234\nabcd\nABCD' | grep '[[:alpha:]]' 下面包含完整的特殊符号及说明： 特殊符号 说明 [:alnum:] 代表英文大小写字节及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字节，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字节 (空白键与 [Tab] 按键) 外的其他所有按键 [:lower:] 代表小写字节，亦即 a-z [:print:] 代表任何可以被列印出来的字节 [:punct:] 代表标点符号 (punctuation symbol)，亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字节，亦即 A-Z [:space:] 任何会产生空白的字节，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节 注意：之所以要使用特殊符号，是因为[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的[a-z]即为所有小写字母，其它语系可能是大小写交替的如，a A b B...z Z，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。 排除字符 1echo 'hello|aloha' | grep '[^o]' 注意:当^放到中括号内为排除字符，否则表示行首。 使用扩展正则表达式，ERE要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep。 数量 1234# 只匹配"zo"echo 'zero\nzo\nzoo' | grep -E 'zo&#123;1&#125;'# 匹配以"zo"开头的所有单词echo 'zero\nzo\nzoo' | grep -E 'zo&#123;1,&#125;' 选择 1234# 匹配"www.baidu.com"和"www.google.com"echo 'www.qq.com\nwww.baidu.com\nwww.google.com' | grep -E 'www\.(baidu|google)\.com'# 或者匹配不包含"baidu"的内容echo 'www.qq.com\nwww.baidu.com\nwww.google.com' | grep -Ev 'www\.baidu\.com' 注意：因为.号有特殊含义，所以需要转义。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Grep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统重装后必备]]></title>
    <url>%2F2016%2F08%2F05%2F2016-08-05-mac-installed-todo%2F</url>
    <content type="text"><![CDATA[“Mac系统常用软件，可以提升工作效率” 程序员必备Homebrew这个是最需要安装的软件，利用homebrew可以快速的安装和管理其他软件包，类似于Fedora系统中的dnf命令。 安装方法如下： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 直接在命令行中输入上述命令即可快速安装homebrew了。 iTerm2Mac自带的终端感觉不是特别方便，可以安装iTerm2，并调整出HotKey Window，就可以快速的开关命令行啦。 直接在官网下载安装包安装即可。常用配置方法如下： 开启HotKey，将打开的窗口选择为Hotkey Window。 将Hotkey Window设置为默认打开窗口。 勾选Hide after opening，这样打开iTerm2的时候默认窗口就会自动隐藏，不用每次都自己隐藏了。上面的红框调整的是窗口的透明度和模糊程度，根据自己的爱好调整即可。 vim命令行必备文本编辑器，brew install vim安装。 git相信有过多人协作开发经验的人对git一定不陌生，直接brew install git即可。 zshbash的功能感觉不够强大，个人觉得还是zsh更加好用一些。 打开命令行，输入命令： 1brew install zsh 安装完成后，可以给刚刚安装的zsh安装主题，安装的前提是安装了git，命令如下： 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 静候安装完成，然后编辑配置文件： 12cd // 切换到自己的根目录vim .zshrc 将ZSH_THEME后面的变量改为自己喜欢的主题名称，地址在zsh主题。 Dash一个非常方便的可以查找API的软件，直接在官网下载安装即可，需要购买。 hexo想要写托管到github的博客并且想马上看到效果，需要安装这款软件，具体安装方法请见我的博客：迁移至Hexo博客。 加快效率的软件 软件名称 推荐理由 alfred 可以视为加强版Spotlight，可以安装各种workflow，极大提升查找效率 moom 预置了几种窗口位置，是对mac自带的最大化的加强 atom 很好用的文本编辑器，界面美观，插件很多 xmind 跨平台的思维导图软件，导师力荐的软件 远程桌面连接 想用Mac控制Windows操作系统必需的软件 Cyberduck 大家都在用的ftp客户端，操作简单 CleanMyMac Mac版的电脑管家 lantern 科学上网的利器 keka 小巧精致的解压缩软件，可以解压各种格式的压缩包 chrome 这个就不用多说了 Karabiner 感觉自己的快捷键不够用了吗？使用这款软件吧 parallel desktop Mac上的最强虚拟机软件 Mac截图小技巧 基础快捷键（+表示同时操作、-表示分步操作） Cmd+Shift+3：全屏截图；截取整个屏幕，保存截图至桌面。 Cmd+Shift+4：区域截图；鼠标光标变成带坐标的小十字，通过拖拽截取特定区域，保存截图至桌面。 Cmd+Shift+4 - 单击空格键 - 鼠标单击指定窗口：窗口截图；出现小十字光标后对指定窗口按空格键，鼠标光标变成照相机，鼠标单击截取指定窗口，保存截图至桌面。 进阶快捷键 Cmd+Shift+4 - 按住空格键拖动鼠标：区域截图；选取区域范围后，按住空格键并拖到鼠标可移动选取范围，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 - 按住Shift - 上下/左右移动鼠标：区域截图；选取区域范围后，按住 Shift 并上下/左右移动鼠标即可固定选取范围宽度/高度改变高度/宽度，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 - 按住Shift和Option: 区域截图；选取区域范围后，按住 Shift 和 Option 键在上一快捷键功能的基础上自由切换高度宽度，释放按键后保存截图至桌面文件夹。 Cmd+Shift+4 - 按住Option: 区域截图；选取区域范围后，按住 Option 键可按比例缩放选取范围，释放按键后保存截图至桌面文件夹。 PS：以上介绍的快捷键配合按住Control键即可将截图文件保存在剪切板，以供调用。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试必会题目（4）—— Math & Bit Manipulation]]></title>
    <url>%2F2016%2F07%2F04%2F2016-07-04-interview-algorithm-math-bit%2F</url>
    <content type="text"><![CDATA[“面试技术岗位应该掌握的算法题目–Math &amp; Bit Manipulation相关” Flip Bits - easy题目 12345678Determine the number of bits required to flip if you want to convert integer nto integer m.ExampleGivenn = 31 (`1`111`1`),m = 14 (`0`111`0`),return 2. 代码 123456789Java:public static int bitSwapRequired(int a, int b) &#123; int count = 0; for (int c = a ^ b; c != 0; c &gt;&gt;&gt;= 1) &#123; count += c &amp; 1; &#125; return count;&#125; 习题地址Flip Bits O(1) Check Power of 2 - easy题目 123456Using O(1) time to check whether an integer n is a power of 2.ExampleFor n=4, return true;For n=5, return false; 代码 123456Java:public boolean checkPowerOf2(int n) &#123; if (n &lt;= 0) return false; return (n &amp; (n-1)) == 0;&#125; 习题地址O(1) Check Power of 2 Unique Paths - easy题目 12345678910A robot is located at the top-left corner of a m x n grid(marked 'Start' in the diagram below).The robot can only move either down or right at any point in time. The robot istrying to reach the bottom-right corner of the grid(marked 'Finish' in the diagrambelow).How many possible unique paths are there?Example 1,1 1,2 1,3 1,4 1,5 1,6 1,7 2,1 3,1 3,7 代码 12345678910111213141516Java:// space O(n)public int uniquePaths(int m, int n) &#123; if (m &lt; 1 || n &lt; 1) return 0; if (m == 1 || n == 1) return 1; int[] result = new int[n]; for (int i = 0; i &lt; n; i++) &#123; result[i] = 1; &#125; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) result[j] += result[j - 1]; &#125; return result[n - 1];&#125; 习题地址Unique Paths Trailing Zeros - easy题目 1234Write an algorithm which computes the number of trailing zeros in n factorial.Example11! = 39916800, so the out should be 2 代码 1234567891011Java:public long trailingZeros(long n) &#123; if (n &lt;= 0) return 0; long count = 0; while(n &gt; 0) &#123; count += n / 5; n /= 5; &#125; return count;&#125; 习题地址Trailing Zeros Update Bits - medium题目 1234567891011121314Given two 32-bit numbers, N and M, and two bit positions, i and j. Write a methodto set all bits between i and j in N equal to M (e g , M becomes a substring of Nlocated at i and starting at j)ClarificationYou can assume that the bits j through i have enough space to fit all of M. That is,if M=10011， you can assume that there are at least 5 bits between j and i.You would not, for example, have j=3 and i=2, because M could not fully fit betweenbit 3 and bit 2.ExampleGiven N=(10000000000)2, M=(10101)2, i=2, j=6return N=(10001010100)2 代码 1234567891011121314151617Java:public int updateBits(int n, int m, int i, int j) &#123; int max = ~0; /* All 1’s */ // 1’s through position j, then 0’s if (j == 31) j = max; else j = (1 &lt;&lt; (j + 1)) - 1; int left = max - j; // 1’s after position i int right = ((1 &lt;&lt; i) - 1); // 1’s, with 0s between i and j int mask = left | right; // Clear i through j, then put m in there return ((n &amp; mask) | (m &lt;&lt; i));&#125; 习题地址Update Bits Unique Binary Search Trees - medium题目 1234567891011Given n, how many structurally unique BSTs (binary search trees) that storevalues 1...n?ExampleGiven n = 3, there are a total of 5 unique BST's.1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \2 1 2 3 代码 12345678910111213Java:public int numTrees(int n) &#123; if (n == 0) return 1; int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] += dp[j] * dp[i - j - 1]; &#125; &#125; return dp[n];&#125; 习题地址Unique Binary Search Trees Fast Power - medium题目 123456Calculate the power(a, n) % b where a, b and n are all 32bit integers.ExampleFor power(2, 31) % 3 = 2For power(100,1000) % 1000 = 0 代码 1234567891011121314151617181920Java:public int fastPower(int a, int b, int n) &#123; long ret = getPower(a, b, n); return (int)ret;&#125;public long getPower(int a, int b, int n)&#123; if(a == 0) return 0; if(n == 0) return 1 % b; if(n == 1) return a % b; long ret = getPower(a, b, n/2); ret *= ret; ret %= b; if(n % 2 == 1)&#123; ret = ret * (a % b); &#125; return ret % b;&#125; 习题地址Fast Power Binary Representation - hard题目 123456789Given a (decimal - e.g. 3.72) number that is passed in as a string, return thebinary representation that is passed in as a string. If the fractional part ofthe number can not be represented accurately in binary with at most 32 characters,return ERROR.ExampleFor n = "3.72", return "ERROR".For n = "3.5", return "11.1". 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Java:public String binaryRepresentation(String n) &#123; // write your code here if (n.indexOf('.') == -1) &#123; return parseInteger(n); &#125; String[] params = n.split("\\."); String flt = parseFloat(params[1]); if (flt == "ERROR") &#123; return flt; &#125; if (flt.equals("0") || flt.equals("")) &#123; return parseInteger(params[0]); &#125; return parseInteger(params[0]) "." flt;&#125;private String parseInteger(String str) &#123; int n = Integer.parseInt(str); if (str.equals("") || str.equals("0")) &#123; return "0"; &#125; String binary = ""; while (n != 0) &#123; binary = Integer.toString(n % 2) binary; n = n / 2; &#125; return binary;&#125;private String parseFloat(String str) &#123; double d = Double.parseDouble("0." str); StringBuilder binary = new StringBuilder(); HashSet&lt;Double&gt; set = new HashSet&lt;Double&gt;(); while (d &gt; 0) &#123; if (binary.length() &gt; 32 || set.contains(d)) &#123; return "ERROR"; &#125; set.add(d); d = d * 2; if (d &gt;= 1) &#123; binary.append(1); d = d - 1; &#125; else &#123; binary.append(0); &#125; &#125; return binary.toString();&#125; 习题地址Binary Representation]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Math</tag>
        <tag>Bit Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式基础]]></title>
    <url>%2F2016%2F06%2F28%2F2016-06-28-regex%2F</url>
    <content type="text"><![CDATA[“工具和灵感，都是利器。当来自不同的领域，不同类型的创造者的工具和灵感互相碰撞的时候，才会迸发出更多的可能性。” 概述正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。 许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由UNIX中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有regexps、regexes、regexen。 在做文字处理或编写程序时，用到查找、替换等功能，使用正则表达式能够简单快捷的完成目标。简单而言，正则表达式通过一些特殊符号的帮助，使用户可以轻松快捷的完成查找、删除、替换等处理程序。例如grep, expr, sed , awk或 vi 中经常会使用到正则表达式，为了充分发挥shell编程的威力,需要精通正则表达式。正规表示法基本上是一种『表示法』， 只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字符串处理之用。 基本语法一个正则表达式通常被称为一个模式（pattern），为用来描述或者匹配一系列符合某个句法规则的字符串。 选择|竖直分隔符表示选择，例如”boy|girl”可以匹配”boy”或者”girl”。 数量限定数量限定除了*,还有+加号,?问号,.点号，如果在一个模式中不加数量限定符则表示出现一次且仅出现一次： + 表示前面的字符必须出现至少一次(1次或多次)，例如，”goo+gle”,可以匹配”gooogle”,”goooogle”等； ? 表示前面的字符最多出现一次(0次或1次)，例如，”colou?r”,可以匹配”color”或者”colour”; * 星号代表前面的字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次），例如，”0*42”可以匹配”42”、”042”、”0042”、”00042”等。 . 匹配除“\n”之外的任何单个字符。例如，“0.42”可以匹配”0i42”、”0w42”、”0142”等。 范围和优先级()圆括号可以用来定义模式字符串的范围和优先级，这可以简单的理解为是否将括号内的模式串作为一个整体。例如，”gr(a|e)y”等价于”gray|grey”，（这里体现了优先级，竖直分隔符用于选择a或者e而不是gra和ey），”(grand)?father”匹配father和grandfather（这里体验了范围，?将圆括号内容作为一个整体匹配）。 语法（部分）正则表达式有多种不同的风格，下面列举一些常用的作为PCRE子集的适用于perl和python编程语言及grep或egrep的正则表达式匹配规则 PCRE（Perl Compatible Regular Expressions中文含义：perl语言兼容正则表达式）是一个用C语言编写的正则表达式函数库，由菲利普.海泽(Philip Hazel)编写。PCRE是一个轻量级的函数库，比Boost之类的正则表达式库小得多。PCRE十分易用，同时功能也很强大，性能超过了POSIX正则表达式库和一些经典的正则表达式库。 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。 ^ 匹配输入字符串的开始位置。 $ 匹配输入字符串的结束位置。 \&lt; 表示词首。 例如\&lt;abc表示以abc为首的词。 \&gt; 表示词尾。 例如abc\&gt;表示以abc结尾的词。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 * 匹配前面的子表达式零次或多次。例如，zo能匹配“z”、“zo”以及“zoo”。``等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 . 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。 (pattern) 匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。 x｜y 匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。 [xyz] 字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号等均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描述；如果如果出现在首位则仅作为普通字符。 [^xyz] 排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 [^a-z] 排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 优先级优先级为从上到下从左到右，依次降低： 运算符 说明 \ 转义符 (), (?:), (?=), [] 括号和中括号 *、+、?、{n}、{n,}、{n,m} 限定符 ^、$、\任何元字符 定位点和序列 ｜ 选择 正则表达式思维导图]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wenknows的利器]]></title>
    <url>%2F2016%2F06%2F27%2Fbenefit_others%2F</url>
    <content type="text"><![CDATA[“工具和灵感，都是利器。当来自不同的领域，不同类型的创造者的工具和灵感互相碰撞的时候，才会迸发出更多的可能性。” 更新记录 2016-06-27 研二期间创建本篇博文2018-05-21 更新工作，更新使用的软件 我和我所做的工作我是Wenknows，现在工作于小红书，职位为电商商户平台后台开发，平时喜欢运动和吃吃吃，业余弹弹尤克里里，喜欢听音乐和评书，喜爱编程，希望在程序猿的道路上能走得更远。 我当前使用的硬件电脑是 14 年的 15 寸 MacBook Pro with Retina，i7处理器，16 GB RAM＋256 GB SSD。 键盘是Cherry的红轴机械键盘MX-BOARD 3.0，键盘比较软，按起来很舒服。 鼠标是罗技的G502。 手机是小米 Note 3，照相很清晰，但是使用时偶尔会有卡顿。 喜欢听音乐，但算不上发烧友，有一个beats录音师的全包式耳机。 我当前使用的软件MAC工作相关 科学上网：Tunnelblick和Lantern，前者是免费的OpenVPN客户端，后者是直接科学上网的工具。 Java：IDEA，感觉是目前最好用的Java IDE，功能强大，界面也很好看。 Python：Pycharm，和IDEA是同一家公司的软件，同样有强大的功能，美观的界面。 Terminal：iTerm2，好用的终端软件，在各大论坛也得到了大家的推荐。 MySQL：MySQL Workbench，MySQL自带可视化管理软件，兼容性好，速度快。 API：Dash，使用MAC的程序员应该都知道这款软件吧。 论文：EndNote，各大论文网站都能生成EndNote格式的引用。 FTP：Cyberduck，被大家广泛推荐的FTP客户端。 生活 浏览器：chrome + 插件，插件安装了Adblock，vimium，Infinity，crxMouse Chrome Gestures，Tampermonkey + 百度网盘助手 邮件：MAC自带邮件，兼容性好，速度飞快。 虚拟机：Parallels Desktop，安装了win 8.1和Fedora 23. 词典：有道词典。 音乐播放器：网易云音乐，感觉它的推荐算法做得很好。 视频播放器：MPlayer，QuickTime和射手播放器。 视频下载：硕鼠MAC，可以下载搜狐等网站的视频。 pdf阅读器：预览和Skim，优点是速度快，都有缺点就是不能创建目录，创建目录的话要用Adobe Acrobat。 压缩软件：keka和Unarchiver，小巧而精致，也得到了大家的推荐。 聊天软件：QQ，微信，应该都是必装的吧。 下载软件：迅雷，uTorrent，迅雷虽然很流氓，但是速度确实快，uTorrent是用于下载bt资源的。 系统增强和提升效率 全局搜索：Alfred，大家应该对这款软件也不陌生。 窗口调整：Moom，预设了几种窗口位置和大小。 个人笔记：有道云笔记和Evernote，用于组织不同形式的文档。 防止睡眠：Caffeine，应该也是耳熟能详的软件了。 文档编辑器：Atom，我是从Sublime转过来的，觉得Atom美观，易用，但是速度方面貌似不如Sublime快。 思维导图：Xmind，实验室导师推荐的思维导图软件，全平台都有。 快捷键：Karabiner，快捷键不够用了吗，使用这款软件吧！ 切换：Contexts，一款增强了程序间切换功能的软件。 娱乐 音乐：Guitar Pro 6 游戏：Lost Castle 平台：Steam Android生活 聊天软件：QQ，微信，这个应该是现在每台中国智能机都会装的软件了吧。 阅读软件：追书小说，Kindle，UC 浏览器，都是用来看书的。 音乐：网易云音乐，比较喜欢的还是中国风和轻音乐。 日历：中华万年历，功能丰富，缺点是广告多了点。 购物：淘宝，京东。 运动：Keep，Pocket Yoga，锻炼身体，责无旁贷。 科学上网：无码VPN，4G也可以科学上网。 音乐学习：Finger，用来练习尤克里里的软件。 记账：口袋记账，功能完善，界面美观。 游戏 小鸡模拟器，可以玩各种主机的游戏 开罗系列游戏--暖暖温泉乡等，小巧而精致的时间杀手游戏 崩溃大陆，非常棒的Rogue like游戏 王者荣耀，最高段位星耀3 最理想的工作环境喜欢扁平化的管理氛围，每个人都积极向上，朝着同一个目标努力。同时也喜欢轻松愉快的企业文化氛围，愿意和能够让自己得到提升的人一起工作。 平时或者工作灵感的方式灵感的迸发不是突然的事情，而必定是靠长期的积累从量变达到质变的过程。 最好的积累方式便是阅读，无论是读书，还是读他人博客的文章，都能得到很好的积累。 还有一个很好的积累方式就是和比自己强的人聊天，了解他们的思维方式，平时的学习习惯，进而对自己进行改变。 工作不要太长时间，要注意劳逸结合，放松的头脑更容易迸发出不一样的能力。 推荐一件生活中的利器给大家一个是我正在使用的科学上网利器：lantern，中文名是蓝灯，免费，速度快。 另一个是高端的桌游：一夜终极狼人，喜欢和小伙伴们撕撕撕的你一定不要错过！ 利他社群计划本文参与了「利器社群计划」，发现更多创造者和他们的工具：利他社群计划]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试必会题目（3）—— Binary Search]]></title>
    <url>%2F2016%2F06%2F26%2F2016-06-26-interview-algorithm-binary-search%2F</url>
    <content type="text"><![CDATA[“面试技术岗位应该掌握的算法题目–Binary Search相关” Sqrt(x) - easy题目 123456789101112Implement int sqrt(int x).Compute and return the square root of x.Examplesqrt(3) = 1sqrt(4) = 2sqrt(5) = 2sqrt(10) = 3 代码 123456789Java:public int sqrt(int x) &#123; if (x &lt;= 0) return 0; long v = x; while(v * v &gt; x) v = (v + (x / v)) &gt;&gt; 1; return (int)v;&#125; 习题地址Sqrt(x) Search Insert Position - easy题目 12345678910111213Given a sorted array and a target value, return the index if the target is found.If not, return the index where it would be if it were inserted in order.You may assume NO duplicates in the array.Example[1,3,5,6], 5 → 2[1,3,5,6], 2 → 1[1,3,5,6], 7 → 4[1,3,5,6], 0 → 0 代码 1234567891011121314Java:public int searchInsert(int[] A, int target) &#123; if (A == null &amp;&amp; A.length &lt; 1) return 0; int low = 0, high = A.length - 1; int mid = 0; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (A[mid] == target) return mid; else if (A[mid] &lt; target) low = mid + 1; else high = mid - 1; &#125; return high - 1;&#125; 习题地址Search Insert Position Search a 2D Matrix - easy题目 12345678910111213141516Write an efficient algorithm that searches for a value in an m x n matrix.This matrix has the following properties:Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row.ExampleConsider the following matrix:[ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]Given target = 3, return true. 代码 12345678910111213141516171819202122232425Java:public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix == null || matrix.length &lt; 1) return false; int row = matrix.length; int column = matrix[0].length - 1; for (int i = 0; i &lt; row; i++) &#123; if (matrix[i][column] == target) return true; else if (matrix[i][column] &lt; target) continue; else return binarySearch(matrix[i], target); &#125; return false;&#125;public boolean binarySearch(int[] arr, int target) &#123; if (arr == null || arr.length &lt; 1) return false; int low = 0, mid = 0, high = arr.length - 1; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (arr[mid] == target) return true; else if (arr[mid] &lt; target) low = mid + 1; else high = mid - 1; &#125; return false;&#125; 习题地址Search a 2D Matrix First Position of Target - easy题目 1234567For a given sorted array (ascending order) and a target number, find the firstindex of this number in O(log n) time complexity.If the target number does not exist in the array, return -1.ExampleIf the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2. 代码 1234567891011121314Java:public int binarySearch(int[] nums, int target) &#123; if (nums == null &amp;&amp; nums.length == 0) return -1; int low = 0, mid = 0, high = nums.length - 1; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (nums[mid] &gt;= target) high = mid - 1; else low = mid + 1; &#125; if (nums[high - 1] == target) return high - 1; else return -1;&#125; 习题地址First Position of Target Wood Cut - medium题目 1234567Given n pieces of wood with length L[i] (integer array). Cut them into small piecesto guarantee you could have equal or more than k pieces with the same length.What is the longest length you can get from the n pieces of wood? Given L &amp; k,return the maximum length of the small pieces.ExampleFor L=[232, 124, 456], k=7, return 114. 代码 123456789101112131415161718192021222324252627Java:public int woodCut(int[] L, int k) &#123; int max = 0; for (int i = 0; i &lt; L.length; i++) &#123; max = Math.max(max, L[i]); &#125; int low = 1, high = max; while (low 1 &lt; high) &#123; int mid = low + (high - low) / 2; if (count(L, mid) &gt;= k) low = mid; else high = mid; &#125; if (count(L, high) &gt;= k) return high; if (count(L, low) &gt;= k) return low; return 0;&#125;public int count(int[] L, int length) &#123; int sum = 0; for (int i = 0; i &lt; L.length; i++) &#123; sum += L[i] / length; &#125; return sum;&#125; 习题地址Wood Cut Find Minimum in Rotated Sorted Array - medium题目 12345678Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).Find the minimum element.ExampleGiven [4, 5, 6, 7, 0, 1, 2] return 0 代码 12345678910111213Java:public int findMin(int[] num) &#123; if (num == null || num.length &lt; 1) return 0; int low = 0, mid = 0, high = num.length - 1; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (num[mid] &gt; num[high]) low = mid 1; else if (num[mid] &lt; num[high]) high = mid; else break; &#125; return num[high];&#125; 习题地址Find Minimum in Rotated Sorted Array Find Peak Element - medium题目 12345678910111213There is an integer array which has the following features:The numbers in adjacent positions are different.A[0] &lt; A[1] &amp;&amp; A[A.length - 2] &gt; A[A.length - 1].We define a position P is a peek if:A[P] &gt; A[P-1] &amp;&amp; A[P] &gt; A[P+1]Find a peak element in this array. Return the index of the peak.ExampleGiven [1, 2, 1, 3, 4, 5, 7, 6]Return index 1 (which is number 2) or 6 (which is number 7) 代码 12345678910111213141516171819Java:public int findPeak(int[] nums) &#123; // write your code here if(nums == null || nums.length &lt; 1) return 0; int start = 0; int end = nums.length - 1; while(start 1 &lt; end) &#123; int mid = start + (end - start) / 2; if(nums[mid] &lt; nums[mid-1]) &#123; end = mid; &#125; else if(nums[mid] &lt; nums[mid+1]) &#123; start = mid; &#125; else &#123; return mid; &#125; &#125; return nums[start] &gt;= nums[end] ? start : end;&#125; 习题地址Find Peak Element First Bad Version - medium题目 12345678910111213141516171819The code base version is an integer start from 1 to n. One day, someone committeda bad version in the code case, so it caused this version and the following versionsare all failed in the unit tests. Find the first bad version.You can call isBadVersion to help you determine which version is the first bad one.The details interface can be found in the code's annotation part.NoticePlease read the annotation in code area to get the correct way to callisBadVersion in different language. For example, Java is SVNRepo.isBadVersion(v)ExampleGiven n = 5:isBadVersion(3) -&gt; falseisBadVersion(5) -&gt; trueisBadVersion(4) -&gt; trueHere we are 100% sure that the 4th version is the first bad version. 代码 123456789101112Java:public int findFirstBadVersion(int n) &#123; if (n &lt; 1) return 0; int low = 0, mid = 0, high = n; while (low &lt; high) &#123; mid = low + (high - low) / 2; if (SVNRepo.isBadVersion(mid)) high = mid; else low = mid + 1; &#125; return low;&#125; 习题地址First Bad Version Search in Rotated Sorted Array - medium题目 12345678910111213Suppose a sorted array is rotated at some pivot unknown to you beforehand.(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).You are given a target value to search. If found in the array return its index,otherwise return -1.You may assume no duplicate exists in the array.ExampleFor [4, 5, 1, 2, 3] and target=1, return 2.For [4, 5, 1, 2, 3] and target=0, return -1. 代码 123456789101112131415161718192021222324Java:public int search(int[] A, int target) &#123; if (A == null || A.length &lt; 1) return -1; int low = 0, mid = 0, high = A.length - 1; while (low &lt;= high) &#123; mid = low + (high - low) / 2; if (A[mid] == target) return mid; else if (A[mid] &lt; A[high]) &#123; if (A[high] &gt;= target &amp;&amp; target &gt;= A[mid]) low = mid + 1; else high = mid - 1; &#125; else &#123; if (A[low] &lt;= target &amp;&amp; target &lt;= A[mid]) high = mid - 1; else low = mid + 1; &#125; &#125; if (A[low] == target) &#123; return low; &#125; if (A[high] == target) &#123; return high; &#125; return -1;&#125; 习题地址Search in Rotated Sorted Array Search for a Range - medium题目 12345678Given a sorted array of n integers, find the starting and ending position of agiven target value.If the target is not found in the array, return [-1, -1].ExampleGiven [5, 7, 7, 8, 8, 10] and target value 8,return [3, 4]. 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Java:public int[] searchRange(int[] A, int target) &#123; if (A.length == 0) &#123; return new int[]&#123;-1, -1&#125;; &#125; int start, end, mid; int[] bound = new int[2]; // search for left bound start = 0; end = A.length - 1; while (start 1 &lt; end) &#123; mid = start + (end - start) / 2; if (A[mid] &gt;= target) &#123; end = mid; &#125; else if (A[mid] &lt; target) &#123; start = mid; &#125; &#125; if (A[start] == target) &#123; bound[0] = start; &#125; else if (A[end] == target) &#123; bound[0] = end; &#125; else &#123; bound[0] = bound[1] = -1; return bound; &#125; // search for right bound start = 0; end = A.length - 1; while (start 1 &lt; end) &#123; mid = start + (end - start) / 2; if (A[mid] &lt;= target) &#123; start = mid; &#125; else &#123; end = mid; &#125; &#125; if (A[end] == target) &#123; bound[1] = end; &#125; else if (A[start] == target) &#123; bound[1] = start; &#125; else &#123; bound[0] = bound[1] = -1; return bound; &#125; return bound;&#125; 习题地址Search for a Range]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础学习]]></title>
    <url>%2F2016%2F06%2F20%2F2016-06-20-linux-basic%2F</url>
    <content type="text"><![CDATA[“Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。” Linux系统简介Linux是一个开源的免费操作系统，如下图所示，Linux就是内核与系统调用接口那两层。 而平常我们使用的应用程序一般都是运行在操作系统之上的，如qq，浏览器，文本编辑器等。 Linux之前Unix的历史早在Linux出现之前20年，就已经有一个相当稳定而成熟的操作系统Unix，那么Unix又是如何诞生的呢？ 1969年以前，Bell实验室、MIT、GE（通用电气公司）的Multics系统 当时的输入设备只有卡片阅读机，输出设备只有打印机，因此如果要测试某个程序，则需要将读卡纸插入卡片机，如果有错误，还需要重新来过。 在一个学校里，主机只有一台，如果有多人使用，就需要等待，20世纪60年代初，MIT开发了分时操作系统，让大型主机可以通过提供多个终端机（Terminal）以连入主机 1965年前后，Bell、MIT、GE共同发起了Multiplexed Information and Computing Service项目，以使大型主机可以同时提供300台以上的终端连接使用，但由于资金短缺，项目进度落后，造成了失败。 1969年，Ken Thompson的小型File Server System 仅仅用4个星期，他就以汇编语言写了一组内核程序， 同时包括一些内核工具程序，以及一个小的文件系统，这个系统就是Unix系统的原型。Thompson将Multics系统简化了不少，同实验室的朋友戏称这个系统为Unics。 这个文件系统有两个重要的概念：① 所有的程序或系统装置都是文件；② 不管构件编辑器还是附属文件，所写的程序只有一个目的，就是有效的完成目标。 1973年，Unix正式诞生，Ritchie等人以C语言写出第一个正式Unix内核 Thompson的操作系统由于其易用性，在贝尔实验室内部广为流传，但由于Unics是汇编语言写的，对于硬件有依赖性，所以他和Ritchie合作想将Unics用高级的程序语言来编写。当时现成的高级语言有B语言，但编译出来的内核性能不好。Ritchie和Thompson将B语言重新改写为C语言，再用C语言改写和编译Unics内核，发行出了Unix正式版本。而由于是C语言改写的内核，Unix很容易被移植到不同机器上。 1977年，重要的Unix分支——BSD诞生 1973年以后，Unix与学术界开始了合作开发，Berkeley大学的Bill Joy取得Unix内核源码后，将其改编，命名为Berkeley Software Distribution（即BSD），Bill Joy也是Sun公司的创办者 1979年，重要的System V架构与版权声明 早期的Unix只能与服务器（Server）或者大型工作站（Workstation）画上等号。而1979年AT&amp;T推出的System V第七版Unix，可以支持x86架构的个人计算机系统。但为了收回Unix版权，增加了”不可对学生提供源码”的严格限制。 1984年之一， x86架构的Minix操作系统诞生 Andrew Tanenbaum（谭宁邦）教授，完全不看Unix源码，自己动手写了Minix这个Unix Like的内核程序，专门用于教学。 1984年之二，GNU项目与FSF基金会成立 Richard Mathew Stallman在1984年发起GNU项目，目的是创建一个自由、开放的Unix操作系统（Free Unix）。他从开发Unix可运行的小程序开始，开发了GCC、Emacs、Bash Shell、GLIBC等软件，打开了GNU项目的知名度，并成立了自由软件基金会 1985 年，GNU的通用公共许可证 为了避免 GNU 开发的自由软件被其他人用作专利软件，因此创建了通用公共许可证（General Public License， GPL），并称呼他为CopyLeft。 1988年， 图形接口XFree86项目 由于GUI的需求日益增加，MIT和其他第三方发布了X Window System，并成立了XFree86这个组织。 1991年，芬兰大学生Linus Torvalds基于bash，gcc开发了Intel 386机器上的内核程序 下面附上Unix系统的家族族谱 Linux的内核版本Linux的内核版本号类似于： 124.3.1-42.e15主版本.次版本.释出版本-修改版本 由于Linux的内核开发者太多，Linux内核经常变动。所以托瓦茨将内核的开发趋势分为两股，并根据两个内核的开发分别给予不同的内核编号： 主、次版本为奇数：开发中版本（development） 如4.1.xx，这种内核版本主要用在测试与开发新功能，所以通常这种版本仅有内核开发工程师会使用 主、次版本为偶数：稳定版本（stable） 如4.2.xx，等到内核功能开发成熟后会加到这类的版本中，主要用在一般家庭计算机及企业版本中。 Linux的特色 自由与开放的使用与学习环境 配置需求低廉 内核功能强大而稳定 独立作业 Linux的优缺点优点： 稳定的系统 免费或少许费用 安全性、漏洞的快速修补 多任务、多用户 用户与用户组的规划 相对比较不耗资源的系统 适合需要小内核程序的嵌入式系统 整合度佳且多样的图形用户界面 缺点： 没有特定的支持厂商 游戏的支持度不足 专业软件的支持度不足 基本概念及操作Linux桌面环境介绍相对于现在的Windows系统，Unix/Linux本身是没有图形界面的，我们通常在Unix/Linux发行版上看到的图形界面实际都只是运行在Linux系统之上的软件。大家熟知的桌面环境有KDE，GNOME，XFCE，LXDE等，用户可以根据自己的需要安装喜欢的桌面环境，甚至定制桌面。 终端（Terminal）在使用Linux系统时，我们并不是直接与计算机系统进行交互，而是通过一个叫做Shell的中间程序来完成。Shell的中文含义是壳，可以理解为包裹在计算机内核外的软件，隐藏了操作系统底层的实现细节，他可以解析我们的命令，并将其转化为计算机可以看懂的字段，将命令交给计算机运行。在Unix/Linux中比较流行的常见的Shell有bash，zsh，ksh，csh等。为了提供一个可以接受用户输入并能够显示输出的窗口，Linux系统在图形界面下提供了一个叫做终端模拟器（Terminal）的程序。在MAC系统上推荐使用的Terminal为iTerm，Linux系统上推荐使用的Terminal为Guake。 Terminal命令行常用快捷键 [Tab] 使用Tab键可以对命令进行快速补全 [Ctrl+c] 使用Ctrl+c可以强行终止当前运行的程序 [Ctrl+a] 使用Ctrl+a可以将光标移至输入行的头部，相当于Home键 [Ctrl+e] 使用Ctrl+e可以将光标移至输入行的尾部，相当于End键 [Ctrl+k] 使用Ctrl+k可以删除从光标所在位置到行尾的所有字符 历史输入命令 ⬆️ 方向键的上键，可以快速查阅输入过的上一条命令 ⬇️ 方向键的下键，可以与上键在输入过的命令间进行切换 order + ⬆️ 输入部分命令后按上键，可以调出上一个包含该order字符的命令 通配符 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配list中的任意单一字符，如[abc]，意为匹配a或b或c [!list] 匹配除list中的任意单一字符以外的字符，如[!abc]，意为不匹配a或b或c [c1-c2] 匹配c1-c2中的任意单一字符 如[0-9]，意为匹配数字0到9任意数字 {s1,s2,…} 匹配s1或s2(或更多)其一字符串 {c1..c2} 匹配c1-c2中全部字符 如{1..10} 用户权限管理Linux是一个可以实现多用户登陆的操作系统，比如“admin”和“visitor”都可以同时登陆同一台主机，他们共享一些主机的资源，但他们也分别有自己的用户空间，用于存放各自的文件。但实际上他们的文件都是放在同一个物理磁盘上的甚至同一个逻辑分区或者目录里，但是由于Linux的用户管理和权限机制，不同用户不可以轻易地查看、修改彼此的文件。 查看用户打开终端，输入命令： 1who am i 可以看到，输入的第一列表示当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用whoami即可），第二列的pts/0中pts表示伪终端，所谓伪是相对于/dev/tty设备而言的，pts/0后面那个数字就表示打开的伪终端序号，第三列则表示当前伪终端的启动时间。 创建用户Linux系统中，root账户拥有整个系统最高的权限，可以对所有账户进行操作。 root权限，系统权限的一种，与SYSTEM权限可以理解成一个概念，但高于Administrator权限，root是Linux和Unix系统中的超级管理员用户帐户，该帐户拥有整个系统至高无上的权力，所有对象他都可以操作，所以很多黑客在入侵系统的时候，都要把权限提升到root权限，获得root权限之后就意味着已经获得了手机的最高权限，这时候你可以对手机中的任何文件（包括系统文件）执行所有增、删、改、查的操作 一般登录系统时都是以普通账户的身份登录的，创建用户需要用到root权限，使用root权限有两种方式，一种是用root用户登录进行操作，另一种是使用sudo命令。 su，su - 与 sudo su &lt;user&gt;可以切换到用户user，执行时需要输入目标用户的密码，sudo &lt;cmd&gt;可以以特权权限运行cmd命令，需要当前用户属于sudo组，且需要输入当前用户密码。su - &lt;user&gt;命令也是切换用户，同时环境变量也会跟着改变成目标用户的环境变量。 利用sudo命令创建一个名为visitor的用户： 1sudo adduser visitor 系统会创建用户，并生成相应的home目录，如果不想生成目录，请使用useradd命令。 使用命令su -l visitor可以切换到visitor用户并将目录切换到其根目录。 退出当前用户使用命令exit或者使用快捷键Ctrl+d。 用户组在Linux中每个用户都有一个归属（用户组），用户组简单地理解就是一组用户的集合，它们共享一些资源和权限，同时拥有私有资源，就跟家的形式差不多，你的兄弟姐妹（不同的用户）属于同一个家（用户组），你们可以共同拥有这个家（共享资源），爸妈对待你们都一样（共享权限），你偶尔写写日记，其他人未经允许不能查看（私有资源和权限）。当然一个用户是可以属于多个用户组的，正如你既属于家庭，又属于学校或公司。 查看自己所在用户组 使用groups命令 其中冒号之前表示用户，后面表示该用户所属的用户组。这里可以看到visitor用户属于visitor用户组，每次新建用户如果不指定用户组的话，默认会自动创建一个与用户名相同的用户组（差不多就相当于家长的意思，或者说是老总）。默认情况下在sudo用户组里的可以使用sudo命令获得root权限。 查看/etc/group文件 /etc/group的内容包括用户组:用户组口令:GID:该用户组所包含的用户，每个用户组一条记录。格式如下： group_name:password:GID:user_list password字段为一个x，表示密码不可见。 将其他用户加入sudo组 默认情况下新创建的用户是不具有root权限的，也不在sudo用户组，可以让其加入sudo用户组从而获取root权限。 12su - l visitorsudo ls 如上述提示，visitor用户不在sudoers文件中，如果想让visitor具有sudo权限，需要将其添加到sudo用户组 使用usermod命令可以为用户添加用户组，同样使用该命令你必需有root权限，你可以直接使用root用户为其它用户添加用户组，或者用其它已经在sudo用户组的用户使用sudo命令获取权限来执行该命令。 1sudo usermod -G sudo visitor 上述命令将visitor用户添加到了sudo组中，可以使用sudo命令获取root权限。 删除用户想要删除用户，需要使用命令： 1sudo userdel -rf visitor 文件权限管理查看文件权限使用ls -l命令列出文件。 每个文件名之前都有一段参数，这些参数的含义如下图： 文件类型 文件类型，分为设备文件（/dev目录下有各种设备文件）socket（网络套接字），pipe(管道)，软链接文件，普通文件和目录这几种。 文件权限 读权限，表示你可以使用tail &lt;file name&gt;之类的命令来读取某个文件的内容，用r表示。 写权限，表示你可以编辑和修改某个文件，用w表示。 执行权限，通常指可以运行的二进制程序文件或者脚本文件，用x表示。 文件类型和权限由10位构成，第一位表示文件的类型，后九位表示文件权限，2-4位表示拥有者权限，5-7位表示用户组权限，8-10位表示其他用户权限，rwx表示可读可写可执行，---表示不可读不可写不可执行，拥有那某个字母表示拥有该字母对应的权限。 拥有者权限表示文件创建者对该文件拥有的权限，用户组权限表示本组用户对该文件所拥有的权限，其他用户权限则表示非创建者和用户组的所有其他用户对该文件拥有的权限。 链接数 链接到该文件所在的inode结点的文件名数目。 文件大小 以inode结点大小为单位来表示的文件大小，可以使用ls -lh来更直观的查看文件的大小。 变更文件所有者用visitor用户创建一个文件。 然后切换回root用户修改文件所有者。 发现文件的所有者变成了root用户。 修改文件权限如果想让自己创建的文件不能被其他用户读、写、执行，需要修改文件的相应权限。共有两种方法进行修改： 二进制数字表示 如4.1.所述，文件权限由后9位表示，每3位为一组，表示不同类型用户拥有的权限，可以将rwx转化为对应的二进制数字： 简单来说，r对应数字4，w对应数字2，x对应数字1。 rwx对应数字为4+2+1 = 7，rw-对应数字为4+2+0 = 6，以此类推。 修改文件权限，需要使用chmod命令： 修改权限后，其他用户就不能读取该文件了： +-符号表示 利用下面的命令，可以达到上述同样的效果 g，o，u分别表示group，others，user。 +，-分别表示增加或者删除相应的权限。 Linux目录结构Unix是以目录为主的，Linux也继承了这一优良特性。Linux是以树形目录结构的形式来构建整个系统的，可以理解为一个用户可操作系统的骨架。虽然本质上无论是目录结构还是操作系统内核都是存储在磁盘上的，但从逻辑上来说Linux的磁盘是挂载在目录上的，每一个目录不仅能使用本地磁盘分区的文件系统，也可以使用网络上的文件系统。 FHS标准在早期的Unix系统中，各个厂家各自定义了自己的Unix系统的文件系统构成，比较混乱，而Linux为了避免这个问题，对文件系统进行了标准化的活动，推出了FHS标准，2004年1月19日发行了最新版本FHS标准2.3。 FHS（英文：Filesystem Hierarchy Standard 中文：文件系统层次结构标准），多数Linux版本采用这种文件组织形式，FHS定义了系统中每个区域的用途、所需要的最小构成的文件和目录同时还给出了例外处理与矛盾处理。 FHS定义了两层规范，第一层是，/下面的各个目录应该要放什么文件数据，例如/etc应该要放置设置文件，/bin与/sbin则应该要放置可执行文件等等。 第二层则是针对/usr及/var这两个目录的子目录来定义。例如/var/log放置系统登录文件、/usr/share放置共享数据等等。 FHS依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四种交互作用的形态: 根目录（/）含义*： 根目录是整个系统最重要的目录，因为不但所有的目录都是由根目录衍生出来的，同时，根目录也与开机、还原、系统修复等操作有关。 FHS建议：根目录所在的分区越小，系统性能就越好，根目录所在的文件系统也较不容易发生问题 以下是重要目录放置的文件内容： 目录 应放置文件内容 /bin 放置一些在单用户维护模式下还能被操作的命令，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等命令 /boot 放置开机会使用到的文件，包括Linux内核文件以及开机菜单与开机所需配置文件等 /dev 以文件形式存放任何设备与接口设备，比较重要的文件：/dev/null, /dev/zero, /dev/tty, /dev/lp*, /dev/hd*, /dev/sd*等 /etc 系统主要的配置文件几乎都放置在这个目录内。FHS建议：不要将可执行文件放到这个目录，比较重要的文件：/etc/inittab, /etc/init.d, /etc/modprobe.conf, /etc/X11, /etc/sysconfig等 /home 系统默认的用户主文件夹，～代表当前用户主文件夹 /lib 放置在开机时会用到的函数库，以及在/bin或/sbin下面的命令会调用的函数库，/lib/modules这个目录放置的驱动程序文件，尤其重要 /media 此目录下的文件都是可删除的设备，常见文件名：/media/cdrom /mnt 用来暂时挂载某些额外设备 /opt 第三方软件放置的目录 /root 系统管理员的主文件夹，/root应该和根目录放在同一个分区中 /srv 存放网络服务所需取用的数据，如：www服务需要的网页数据就可以放置在/srv/www里面 /tmp 任何人都可以访问这个目录，这是用于暂时放置文件的地方，重要的数据都不可以放到这个目录里面，FHS建议：每次开机时都清空一下这个目录 /sbin 放置了开机过程所需的命令，包括开机、修复、还原系统所需的命令 注意： 开机过程中，只有根目录会被挂载，其他分区则是在开机完成后才会持续进行挂载，所以在根目录下与开机相关的目录都不能与根目录放到不同的分区中。 从上表可以轻易得出，下列五个目录一定不可与根目录分开： /etc—-配置文件 /bin—-重要执行文件 /dev—-所需要的设备文件 /lib—-执行文件所需要的函数库与内核所需的模块 /sbin—-重要的系统执行文件 目录路径路径是指某个目录或文件所在的位置，分为绝对路径和相对路径两种： 绝对路径 是以根&quot;/&quot;目录为起点的完整路径，以你所要到的目录为终点，表现形式如：/usr/local，表示根目录下的usr目录中的local目录。 相对路径 相对路径，是相对于当前目录的路径，相对路径是以当前目录.为起点，以所要到的目录为终点，表现形式如：local/bin。因为这个目录为 当前目录下的子目录，是可以省略这个.的；如果是当前目录的上一级目录，则需要使用..，比如你当前目录为home目录，根目录就应该表示为../ ,表示当前目录（home目录）的上一级目录（/目录）。 使用cd命令可以切换目录，在Linux中，.表示当前目录，..表示上一级目录, -表示上一次所在目录，～通常表示当前用户的home目录。使用pwd命令可以获取当前所在路径（绝对路径）。 进入上一级目录： 1cd .. 进入本用户home目录 1cd ~ 使用pwd获取当前路径 1pwd 提示：在进行目录切换的过程中请多使用Tab键自动补全，可避免输入错误，连续按两次Tab可以显示全部候选结果。 Linux文件的基本操作新建 新建空白文件 使用touch命令创建空白文件，可以创建一个不会覆盖已有同名文件的空白文件。 新建有预定内容的文件 使用echo &quot;content&quot; &gt; filename命令，可以创建一个拥有content内容的名为filename的文件。 新建目录 使用mkdir命令可以创建一个空白目录，使用-p参数可以同时创建父目录。 复制 复制文件 使用cp命令可以复制一个文件到指定目录。 复制目录 使用cp -r或cp -R命令，可以递归复制目录及其中的文件到指定目录。 删除 删除文件 使用rm命令，可以删除一个文件。使用参数-f可以强制删除文件。 删除目录 使用rm -r命令，可以删除一个目录。 移动文件与文件重命名 移动文件 使用mv命令可以移动文件，使用方法为mv 源文件 目的目录。 重命名文件 使用mv命令还可以重命名文件，使用方法为mv 旧文件名 新文件名。 批量重命名 使用rename命令可以通过perl正则表达式进行批量重命名： 12345678# 使用通配符批量创建 5 个文件touch file&#123;1..5&#125;.txt# 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件rename 's/\.txt/\.c/' *.txt# 批量将这 5 个文件，文件名改为大写rename 'y/a-z/A-Z/' *.c rename是先使用第二个参数的通配符匹配所有后缀为.txt的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的.txt后缀替换为.c。 查看文件 使用cat，tac和nl命令查看文件 这三个命令都是用来打印文件内容到标准输出,其中cat为正序显示，tac倒序显示，nl添加行号并打印。 标准输入输出：当我们执行一个shell命令行时通常会自动打开三个标准文件，即标准输入文件stdin，默认对应终端的键盘；标准输出文件stdout和标准错误输出文件stderr，这两个文件都对应被重定向到终端的屏幕，以便我们能直接看到输出内容。进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息送到标准错误文件中。 比如我们要查看/local文件夹下的test.txt文件： 1cat test.txt 可以加上参数-n显示行号： 1cat -n test.txt nl命令，添加行号并打印，是比cat -n更专业的行号打印命令。他有以下几个常用参数： 12345678-b : 指定添加行号的方式，主要有两种： -b a:表示无论是否为空行，同样列出行号("cat -n"就是这种方式) -b t:只列出非空行的编号并列出（默认为这种方式）-n : 设置行号的样式，主要有三种： -n ln:在行号字段最左端显示 -n rn:在行号字段最右边显示，且不加 0 -n rz:在行号字段最右边显示，且加 0-w : 行号字段占用的位数(默认为6位) 以上三个命令都是在当前窗口显示文本，一屏显示不完文本的内容，需要用鼠标拖动滚动条或者滑动滚轮才能继续往下翻页，如果能够用键盘直接进行翻页操作的话会更加方便，这就需要使用下面的几个命令。 使用more和less命令分页查看文件 这两个命令都能够实现用键盘向下翻页的操作，其中more命令翻页到最后一行时会自动退出命令，而less的功能更加强大，他是基于more和vi开发的，会新打开一个页面显示文本内容，只要不按q推出，可以随意翻页。 比如我们要使用more命令查看一个单页放不下的test.txt文件： 1more test.txt 打开后默认只显示一屏内容，终端底部显示当前阅读的进度(百分比)，翻到尾行时命令会自动退出。可以使用Enter键向下滚动一行，使用Space键向下滚动一屏，按下h显示帮助，q退出。 如果我们使用less命令查看单页放不下德 test.txt： 1less test.txt 可以看到，翻到尾行时命令不会退出，而是显示End，表示已经到达了尾行。 使用head和tail命令查看文件 正如命令的名称，head命令只查看文件的头几行（默认为10行，不足10行则显示全部），tail命令只查看文件的尾几行。 两个命令的输入方式如下： 1234head test.txthead -n 1 test.txttail test.txttail -n 1 test.txt 关于tail命令，还有一个很实用的参数-f，这个参数可以实现不停地读取某个文件的内容并显示。让我们可以动态查看日志，起到实时监视的作用。 查看文件类型我们可以使用file命令查看文件的类型： 1file test.txt 这表示test.txt是一个由ASCII编码的文本文件。 环境变量变量要了解环境变量，首先要了解Shell变量，所谓变量就是计算机中用于记录一个值（不一定是数值，也可以是字符或字符串）的符号，而这些符号将用于不同的运算处理中。通常变量与值是一对一的关系，可以通过表达式读取它的值赋值给其它变量，也可以直接指定数值赋值给任意变量。为了便于运算和处理，大部分的编程语言会区分变量的类型，用于分别记录数值、字符或者字符串等等数据类型。Shell中的变量也基本如此，有不同类型（但不用专门指定类型名），可以参与运算，有作用域限定。 变量的作用域即变量的有效范围（比如一个函数中、一个源文件中或者全局范围），在该范围内只能有一个同名变量。一旦离开则该变量无效，如同不存在这个变量一般。 创建变量 使用declare命令可以创建一个变量： 1declare tmp 其实也可以不用declare预声明一个变量，直接用的时候创建即可。 使用=符号（不要加空格）赋值运算符可以为变量tmp赋值： 1tmp=nihao 读取变量的值，使用echo命令和$符号（一定要加$符号，不然输出的是变量名而不是他的值）： 1echo $tmp 注意:关于变量名，并不是任何形式的变量名都是可用的，变量名只能是英文字母,数字或者下划线，且不能以数字作为开头。 环境变量环境变量就是作用域比自定义变量要大，如Shell的环境变量作用于自身和它的子进程。在所有的Unix和类Unix系统中，每个进程都有其各自的环境变量设置，且默认情况下，当一个进程被创建时，处理创建过程中明确指定的话，它将继承其父进程的绝大部分环境设置。Shell程序也作为一个进程运行在操作系统之上，而我们在Shell中运行的大部分命令都将以Shell的子进程的方式运行。 通常我们会涉及到的环境变量有三种： 当前Shell进程私有用户自定义变量，如上面我们创建的tmp变量，只在当前Shell中有效。 Shell本身内建的变量。 从自定义变量导出的环境变量。 也有三个与上述三种环境变量相关的命令，set，env，export。这三个命令很相似，都可以用于打印相关环境变量,区别在于涉及的是不同范围的环境变量，详见下表： 命令 说明 set 显示当前Shell所有环境变量，包括其内建环境变量（与Shell外观等相关），用户自定义变量及导出的环境变量 env 显示与当前用户相关的环境变量，还可以让命令在指定环境中运行 export 显示从Shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量 关于环境变量，可以简单的理解成在当前进程的子进程是否有效，有效则为环境变量，否则不是。 注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。 命令的查找路径与顺序我们在Shell中输入一个命令，他是怎么找到相应的命令并执行的呢？答案是通过环境变量PATH来进行搜索的。 查看PATH环境变量的内容： 1echo $PATH 上面这些目录中放的都是可执行文件，当我们在Shell中执行一个命令时，系统就会按照PATH中设定的路径按照顺序依次到目录中去查找，如果存在同名的命令，则执行先找到的那个。 添加自定义路径到PATH环境变量PATH环境变量中是以:作为路径的分隔符，我们可以这样添加自定义路径： 1PATH = $PATH:/home/wen/bin 注意：PATH路径一定要使用绝对路径 但是给PATH环境变量追加了一个路径，它也只是在当前Shell有效，一旦退出终端，再打开就会发现失效了。有没有方法让添加的环境变量全局有效？或者每次启动Shell时自动执行上面添加自定义路径到PATH的命令？ 在每个用户的home目录中有一个Shell每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh的配置文件是.zshrc，相应Bash的配置文件为.bashrc。它们在etc下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。 我们可以简单的使用下面命令直接添加内容到.zshrc中： 1echo "PATH=$PATH:/home/wen/bin" &gt;&gt; .zshrc 上述命令中&gt;&gt;表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的&gt;是以覆盖的方式重定向到一个文件中，使用的时候一定要注意分辨。在指定文件不存在的情况下都会创建新的文件。 或者使用vi或vim或其他文本编辑器打开.zshrc文件，找到PATH行，将内容添加进PATH的配置中。 修改和删除已有变量 变量修改 变量的修改有以下几种方式： 变量设置方式 说明 ${变量名#匹配字串} 从头向后开始匹配，删除符合匹配字串的最短数据 ${变量名##匹配字串} 从头向后开始匹配，删除符合匹配字串的最长数据 ${变量名%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最短数据 ${变量名%%匹配字串} 从尾向前开始匹配，删除符合匹配字串的最长数据 ${变量名/旧的字串/新的字串} 将符合旧字串的第一个字串替换为新的字串 ${变量名//旧的字串/新的字串} 将符合旧字串的全部字串替换为新的字串 比如要修改我们前面添加到PATH的环境变量。为了避免操作失误导致命令找不到，我们先将PATH赋值给一个新的自定义变量path： 12345$ path=$PATH$ echo $path$ path=$&#123;path%/home/wen/bin&#125;# 或使用通配符,*表示任意多个任意字符$ path=$&#123;path%*/bin&#125; 变量删除 可以使用unset命令删除一个环境变量： 1unset tmp 如何让环境变量立即生效我们在Shell中修改了一个配置脚本文件之后（比如zsh的配置文件home目录下的.zshrc），需要退出终端重新打开甚至重启主机之后其才能生效，我们可以使用source命令来让其立即生效，如： 1source .zshrc source命令还有一个别名就是.，但后面的文件必须指定完整的绝对或相对路径名： 1. ./.zshrc 第一个.表示source命令，第二个.表示当前目录。 搜索文件与搜索相关的命令常用的有如下几个whereis，locate，which，find。 whereis简单快速1whereis test whereis只能搜索二进制文件(-b)，man帮助文件(-m)和源代码文件(-s)。和find相比，whereis查找的速度非常快，这是因为Linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 locate快而全locate让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。locate通过/var/lib/mlocate/mlocate.db数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行updatedb命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次updatedb命令。 它可以用来查找指定目录下的不同文件类型，如查找/usr下所有以src开头的文件： 1locate /usr/src 注意：它不只是在usr目录下查找，还会自动递归子目录进行查找。 查找/usr/share/下所有jpg文件： 注意：*号前面要添加反斜杠(\)转义，否则会无法找到。 如果想只统计数目可以加上-c参数，-i参数可以忽略大小写进行查找，whereis的-b,-m，-s同样可以使用。 which小而精which本身是Shell内建的一个命令，我们通常使用which来确定是否安装了某个指定的软件，因为它只从PATH环境变量中执行的路径中去搜索命令。 1which man find精而细Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多。即使系统中含有网络文件系统(NFS)，find命令在该文件系统中同样有效，只要你具有相应的权限。 在指定目录下搜索指定文件名的文件： 1find / -name 'test.txt' find命令的路径是作为第一个参数的， 基本命令格式为find [path] [option] [action]。 基本命令选项： -name 按照文件名查找文件。 -perm 按照文件权限来查找文件。 -prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 -user 按照文件属主来查找文件。 -group 按照文件所属的组来查找文件。 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。 -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件。 -type 查找某一类型的文件，诸如： b - 块设备文件。 d - 目录。 c - 字符设备文件。 p - 管道文件。 l - 符号链接文件。 f - 普通文件。 与时间相关的命令参数： 参数 说明 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 下面以-mtime参数举例： -mtime n: n为数字，表示为在n天之前的”一天之内“修改过的文件 -mtime +n: 列出在n天之前（不包含n天本身）被修改过的文件 -mtime -n: 列出在n天之前（包含n天本身）被修改过的文件 实例： 查找指定时间内修改过的文件 1find -mtime -2 查找2 * 24小时之内被修改过的文件。 根据关键字查找 1find . -name "test.txt" 在当前目录查找文件名为test.txt的文件。 按照目录或文件的权限查找文件 1find . -perm 765 查找当前目录下权限为765的文件。 按照类型查找 1find . -type f -name "*.xml" 查找当前目录下以xml结尾的普通文件。 按照文件内容查找 1find . -name "*.txt" | xargs grep "test*" 查找当前目录下含有test开头的所有txt文件。 文件打包和解压缩在Linux上常用的是tar工具，常用的压缩命令还有compress，gzip和bzip2等。 常用的命令如下： 123456789101112131415161718192021compress filename 将文件压缩成.Z格式gzip filename 将文件压缩成.gz格式bzip2 filename 将文件压缩成.bz2格式以上三个命令 -d 将相应的文件解压缩tar dest source 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 实例： tar -cvf /local/test.tar /local/test 只打包，不压缩 tar -zcvf /local/test.tar.gz /local/test 打包，并用gzip压缩 tar -jcvf /local/test.tar.bz2 /local/test 打包，并用bzip2压缩 tar -xvf /local/test.tar /local/test 只拆包 tar -zxvf /local/test.tar.gz /local/test 用gzip解压缩，并拆包 tar -jxvf /local/test.tar.bz2 /local/test 用bzip2解压缩，并拆包 文件系统操作查看磁盘和目录的容量 使用df命令查看磁盘的容量 1df 一般使用情况下，我们更多只是关心/dev/sda1的内容。 物理主机上的/dev/sda1是对应着主机硬盘的分区，后面的数字表示分区号，数字前面的字母a表示第几块硬盘（也可能是可移动磁盘），你如果主机上有多块硬盘则可能还会出现/dev/sdb，/dev/sdc这些磁盘设备都会在/dev目录下以文件的存在形式。 我们还可以看到1k-块(1k-blocks)这个陌生的名词，它表示以磁盘块大小的方式显示容量，后面为相应的以块大小表示的已用和可用容量。 可以用参数-h转化为更为直观的方式： 1df -h 使用du命令查看目录的容量 1234# 默认同样以 blocks 的大小展示du# 加上`-h`参数，以更易读的方式展示du -h -d参数指定查看目录的深度 1234# 只查看1级目录的信息du -h -d 0 ~# 查看2级du -h -d 1 ~ 命令执行顺序的控制顺序执行多条命令通常情况下，我们每次只能在终端输入一条命令，按下回车执行，执行完成后，我们再输入第二条命令，然后再按回车执行…… 但是我们可能会遇到如下使用场景：我们需要使用apt-get安装一个软件，然后安装完成后立即运行安装的软件（或命令工具），又恰巧你的主机没有更新软件列表,那么你可能会有如下一系列操作： 12345sudo apt-get update# 等待——————————然后输入下面的命令sudo apt-get install software# 等待——————————然后输入下面的命令software 这样的输入方式比较浪费我们的时间，我们可能想要一次性输入完命令，并让系统自动运行。 简单的顺序执行可以使用;来完成： 12sudo apt-get update;sudo apt-get install software;software# 让它自己运行 有选择的执行命令如果自动顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就会造成花了时间，最终却得到一个错误的结果，而且有时候无法判断结果是否正确。此时我们需要能够有选择性的执行命令，比如上一条命令执行成功才继续下一条： 1which cowsay &amp;&amp; cowsay -f head-in ohch~ 如果没有安装cowsay，执行一次上述命令，会发现什么也没发生，如果安装了cowsay，会出现以下效果： 上面的&amp;&amp;就是用来实现选择性执行的，它表示如果前面的命令执行结果返回0则执行后面的，否则不执行，你可以从$?环境变量获取上一次命令的返回结果： &amp;&amp;表示逻辑与，||表示逻辑或，shell可以用两个符号实现命令执行顺序的简单控制。||在这里就是与&amp;&amp;相反的控制效果，即当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令： 1which cowsay || echo "cowsay not found" 同时我们可以将&amp;&amp;命令和||命令综合起来进行使用，比如： 1which cowsay &amp;&amp; echo "exist" || echo "not exist" 上面命令运行的流程如下： 管道管道是一种通信机制，通常用于进程间的通信（也可通过socket进行网络通信），它表现出来的形式就是将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)。 管道又分为匿名管道和具名管道。具名管道简单的说就是有名字的管道，通常只会在源程序中用到具名管道。我们在使用一些过滤程序时经常会用到的就是匿名管道，在命令行中由|分隔符表示。 匿名管道输入命令： 1ls -al /etc 上述命令结果很多，屏幕不能完全显示，可以使用管道命令： 1ls -al /etc | less 会将前一个命令ls的输出传递给下一个命令less，然后可以进行less命令的操作。 cut命令cut命令可以将文件进行处理后输出： 123456789101112# 输出每行前五个字符（包含第五个）cut /etc/passwd -c -5# 输出每行前五个之后的字符（包含第五个）cut /etc/passwd -c 5-# 输出每行第五个字符cut /etc/passwd -c 5# 输出每行2到5之间的字符（包含第五个）cut /etc/passwd -c 2-5# 将分隔符变为:分割出不同的field，并输出第1个和第2个fieldcut /etc/passwd -d ':' -f 1,2# 将分隔符变为:分割出不同的field，并输出第1个到第4个fieldcut /etc/passwd -d ':' -f 1-4 grep命令grep命令是很强大的，也是相当常用的一个命令，它结合正则表达式可以实现很复杂却很高效的匹配和查找。 grep命令的一般形式为：grep [命令选项] 用于匹配的表达式 [文件] 例如，搜索当前目录下所有包含test的所有文件，并显示出现在文本中的行号： 1grep -rnI "test" . -r参数表示递归搜索子目录中的文件,-n表示打印匹配项行号，-I表示忽略二进制文件。 也可以在匹配字段中使用正则表达式： 12# 查看环境变量中以"bin"结尾的字符串$ export | grep ".*bin$" wc命令wc命令用于统计并输出一个文件中行、单词和字节的数目： 1234567891011wc /etc/passwd# 行数wc -l /etc/passwd# 单词数wc -w /etc/passwd# 字节数wc -c /etc/passwd# 字符数wc -m /etc/passwd# 最长行字节数wc -L /etc/passwd 注意：对于西文字符来说，一个字符就是一个字节，但对于中文字符一个汉字是大于2个字节的，具体数目是由字符编码决定的。 结合管道来操作一下，下面统计/etc下面所有目录数： 1ls -dl /etc/*/ | wc -l sort命令功能是将输入按照一定方式排序，然后再输出,它支持的排序有按字典排序,数字排序，按月份排序，随机排序，反转排序，指定特定字段进行排序等等。 默认为字典排序： 1cat /etc/passswd | sort 反转排序： 1cat /etc/passwd | sort -r 按特定字段排序： 1cat /etc/passwd | sort -t':' -k 3 上面的-t参数用于指定字段的分隔符，这里是以:作为分隔符；-k字段号用于指定对哪一个字段进行排序。这里/etc/passwd文件的第三个字段为数字，默认情况下是一字典序排序的，如果要按照数字排序就要加上-n参数： 1$ cat /etc/passwd | sort -t':' -k 3 -n uniq命令uniq命令可以用于过滤或者输出重复行。 过滤重复行 我们可以使用history命令查看最近执行过的命令，不过你可能只想查看使用了那个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令： 1history | cut -c 8- | cut -d ' ' -f 1 | uniq 由于uniq命令只能去连续重复的行，不是全文去重，所以要达到全文去重效果，我们需要先排序： 12history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq# 或者$ history | cut -c 8- | cut -d ' ' -f 1 | sort -u 输出重复行 1234# 输出重复过的行（重复的只输出一个）及重复次数history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc# 输出所有重复的行history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D 常用文本处理命令tr命令tr命令可以用来删除一段文本信息中的某些文字。或者将其进行转换。 使用方式：tr [option]…SET1 [SET2] 常用的选项有： 选项 说明 -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配 -s 去除set1指定的在输入文本中连续并重复的字符 操作举例： 123456# 删除 "hello world" 中所有的'o','l','h'echo 'hello world' | tr -d 'olh'# 将"hello" 中的ll,去重为一个lecho 'hello' | tr -s 'l'# 将输入文本，全部转换为大写或小写输出echo 'hello world' | tr '[a-z]' '[A-Z]' col命令col命令可以将Tab换成对等数量的空格建，或反转这个操作。 使用方式： 1col [option] 常用的选项有： 选项 说明 -x 将Tab转换为空格 -h 将空格转换为Tab（默认选项） 操作举例： 1234# 查看 /etc/protocols 中的不可见字符，可以看到很多 ^I ，这其实就是 Tab 转义成可见字符的符号cat -A /etc/protocols | tail -n 5# 使用 col -x 将 /etc/protocols 中的 Tab 转换为空格,然后再使用 cat 查看，你发现 ^I 不见了cat /etc/protocols | col -x | tail -n 5 join命令join命令用于将两个文件中包含相同内容的那一行合并在一起。 使用方式： 1join [option]... file1 file2 常用的选项有： 选项 说明 -t 指定分隔符，默认为空格 -i 忽略大小写的差异 -1 指明第一个文件要用哪个字段来对比，，默认对比第一个字段 -2 指明第二个文件要用哪个字段来对比，，默认对比第一个字段 操作举例： 12345678# 创建两个文件echo 'haha 1:hello haha' &gt; file1echo 'haha 1:world hehe' &gt; file2join file1 file2# 将file1与file2两个文件合并，指定以':'作为分隔符sudo join -t':' file1 file2# 将file1与file2两个文件合并，指定以':'作为分隔符, 分别比对第1和第1个字段sudo join -t':' -1 1 file1 -2 1 file2 paste命令paste命令与join命令类似，它是在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。 使用方式：1paste [option] file... 常用的选项有： 选项 说明 -d 指定合并的分隔符，默认为Tab -s 不合并到一行，每个文件为一行 操作举例： 12345echo hello &gt; file1echo world &gt; file2echo wenzhiquan &gt; file3paste -d ':' file1 file2 file3paste -s file1 file2 file3]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试必会题目（2）—— Array]]></title>
    <url>%2F2016%2F06%2F15%2F2016-06-15-interview-algorithm-array%2F</url>
    <content type="text"><![CDATA[“面试技术岗位应该掌握的算法题目–Array相关” Remove Element - easy题目 12345678910Given an array and a value, remove all occurrences of that value in place andreturn the new length.The order of elements can be changed, and the elements after the new lengthdon't matter.ExampleGiven an array [0,4,4,0,0,2,4,4], value=4return 4 and front four elements of the array is [0,0,0,2] 代码 123456789101112131415Java:public int removeElement(int[] A, int elem) &#123; if (A == null || A.length == 0) return 0; int step = 0; for (int i = 0; i &lt; A.length; i++) &#123; if (A[i] == elem) &#123; step++; continue; &#125; else &#123; A[i - step] = A[i]; &#125; &#125; return A.length - step;&#125; 习题地址Remove Element Subarray Sum - easy题目 12345Given an integer array, find a subarray where the sum of numbers is zero. Yourcode should return the index of the first number and the index of the last number.ExampleGiven [-3, 1, 2, -3, 4], return [0, 2] or [1, 3]. 代码 12345678910111213141516171819202122232425Java:public ArrayList&lt;Integer&gt; subarraySum(int[] nums) &#123; int len = nums.length; ArrayList&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, -1); int sum = 0; for (int i = 0; i &lt; len; i++) &#123; sum += nums[i]; if (map.containsKey(sum)) &#123; ans.add(map.get(sum) 1); ans.add(i); return ans; &#125; map.put(sum, i); &#125; return ans;&#125; 习题地址Subarray Sum Remove Duplicates from Sorted Array - easy题目 12345678910Given a sorted array, remove the duplicates in place such that each element appearonly once and return the new length.Do not allocate extra space for another array, you must do this in place withconstant memory.ExampleGiven input array A = [1,1,2],Your function should return length = 2, and A is now [1,2]. 代码 123456789101112131415161718Java:public int removeDuplicates(int[] nums) &#123; final int k = 1; // k means the max appear times of the duplicates if(nums.length == 0) return 0; int start = 1; int count = 1; for(int i = 1; i &lt; nums.length; ++i) &#123; if(nums[i] == nums[i - 1]) &#123; if(count &lt; k) nums[start++] = nums[i]; count++; &#125; else &#123; count = 1; nums[start++] = nums[i]; &#125; &#125; return start;&#125; 习题地址Remove Duplicates from Sorted Array Merge Sorted Array - easy题目 123456Given two sorted integer arrays A and B, merge B into A as one sorted array.ExampleA = [1, 2, 3, empty, empty], B = [4, 5]After merge, A will be filled as [1, 2, 3, 4, 5] 代码 12345678910111213141516Java:public void mergeSortedArray(int[] A, int m, int[] B, int n) &#123; if (n == 0) return; int i = m - 1, j = n - 1; while (i &gt;=0 &amp;&amp; j &gt;= 0) &#123; if (A[i] &lt; B[j]) &#123; A[i + j - 1] = B[j--]; &#125; else &#123; A[i + j - 1] = A[i--]; &#125; &#125; while (j &gt;= 0) &#123; A[i + j - 1] = B[j--]; &#125;&#125; 习题地址Merge Sorted Array Product of Array Exclude Itself - easy题目 1234567Given an integers array A.Define B[i] = A[0] * ... * A[i-1] * A[i+1] * ... * A[n-1], calculate B WITHOUTdivide operation.ExampleFor A = [1, 2, 3], return [6, 3, 2]. 代码 1234567891011121314151617181920Java:public ArrayList&lt;Long&gt; productExcludeItself(ArrayList&lt;Integer&gt; A) &#123; // write your code int length = A.size(); ArrayList&lt;Long&gt; result = new ArrayList&lt;&gt;(); if (length &lt; 1) return result; long tmp = 1; for (int i = 0; i &lt; length; i++) &#123; result.add(tmp); tmp *= A.get(i); &#125; tmp = 1; for (int i = length - 1; i &gt;= 0; i--) &#123; Long data = result.get(i); result.set(i, data * tmp); tmp *= A.get(i); &#125; return result;&#125; 习题地址Product of Array Exclude Itself First Missing Positive - medium题目 12345Given an unsorted integer array, find the first missing positive integer.ExampleGiven [1,2,0] return 3,and [3,4,-1,1] return 2. 代码 12345678910111213141516171819202122Java:public int firstMissingPositive(int[] A) &#123; // write your code here int length = A.length; if (length &lt; 1) return 1; int i = 0; while (i &lt; length) &#123; if (A[i] &gt;= 0 &amp;&amp; A[i] &lt; length &amp;&amp; A[A[i]] != A[i]) swap(A, i, A[i]); else i++; &#125; int k = 1; while (k &lt; length &amp;&amp; A[k] == k) k++; if (length == 0 || k &lt; length) return k; else return A[0] == k? k + 1: k;&#125;public void swap(int[] arr, int i, int j) &#123; int tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;&#125; 习题地址First Missing Positive 3Sum Closest - medium题目 123456Given an array S of n integers, find three integers in S such that the sum isclosest to a given number, target. Return the sum of the three integers.ExampleFor example, given array S = [-1 2 1 -4], and target = 1. The sum that is closestto the target is 2. (-1 2 1 = 2). 代码 123456789101112131415161718192021222324252627Java:public int threeSumClosest(int[] numbers, int target) &#123; // write your code here int result = 0; if (numbers == null || numbers.length &lt; 3) return result; int min = Integer.MAX_VALUE; int i = 0; Arrays.sort(numbers); while (i &lt; numbers.length - 2) &#123; int j = i 1; int k = numbers.length - 1; while (j &lt; k) &#123; int sum = numbers[i] numbers[j] numbers[k]; if (sum == target) return sum; else if (sum &lt; target) while (numbers[j] == numbers[++j] &amp;&amp; j &lt; k); else while (numbers[k] == numbers[--k] &amp;&amp; j &lt; k); int diff = Math.abs(sum - target); if (diff &lt; min) &#123; min = diff; result = sum; &#125; &#125; while (numbers[i] == numbers[++i] &amp;&amp; i &lt; numbers.length - 2); &#125; return result;&#125; 习题地址3Sum Closest 3Sum - medium题目 12345678Given an array S of n integers, are there elements a, b, c in S such thata b c = 0? Find all unique triplets in the array which gives the sum of zero.ExampleFor example, given array S = &#123;-1 0 1 2 -1 -4&#125;, A solution set is:(-1, 0, 1)(-1, -1, 2) 代码 1234567891011121314151617181920212223242526272829Java:public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; threeSum(int[] numbers) &#123; // write your code here ArrayList&lt;ArrayList&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); if (numbers == null || numbers.length &lt; 3) return result; Arrays.sort(numbers); int i = 0; while (i &lt; numbers.length - 2) &#123; if (numbers[i] &gt; 0) break; int j = i 1; int k = numbers.length - 1; while (j &lt; k) &#123; int sum = numbers[i] numbers[j] numbers[k]; if (sum == 0) &#123; ArrayList&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); tmp.add(numbers[i]); tmp.add(numbers[j]); tmp.add(numbers[k]); result.add(tmp); &#125; if (sum &lt;= 0) while (numbers[j] == numbers[++j] &amp;&amp; j &lt; k); if (sum &gt;= 0) while (numbers[k] == numbers[--k] &amp;&amp; j &lt; k); &#125; while (numbers[i] == numbers[++i] &amp;&amp; i &lt; numbers.length - 2); &#125; return result;&#125; 习题地址3Sum Two Sum - medium题目 1234567891011Given an array of integers, find two numbers such that they add up to a specifictarget number.The function twoSum should return indices of the two numbers such that they addup to the target, where index1 must be less than index2. Please note that yourreturned answers (both index1 and index2) are NOT zero-based.Examplenumbers=[2, 7, 11, 15], target=9return [1, 2] 代码 12345678910111213141516171819Java:public int[] twoSum(int[] numbers, int target) &#123; // write your code here if (numbers == null ||numbers.length &lt; 1) return null; HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;(); int [] result = new int[2]; for (int i = 0; i &lt; numbers.length; i++) &#123; int key = target - numbers[i]; if (hashMap.containsKey(key)) &#123; result[0] = hashMap.get(key); result[1] = i + 1; break; &#125; else &#123; hashMap.put(numbers[i], i + 1); &#125; &#125; return result;&#125; 习题地址Two Sum Partition Array - medium题目 123456789Given an array nums of integers and an int k, partition the array(i.e move the elements in "nums") such that:All elements &lt; k are moved to the leftAll elements &gt;= k are moved to the rightReturn the partitioning index, i.e the first index i nums[i] &gt;= k.ExampleIf nums = [3,2,2,1] and k=2, a valid answer is 1. 代码 123456789101112131415161718192021Java:public int partitionArray(int[] nums, int k) &#123; //write your code here if (nums == null || nums.length &lt; 1) return 0; int low = 0, high = nums.length - 1; while (low &lt;= high) &#123; while (low &lt;= high &amp;&amp; nums[high] &gt;= k) high--; while (low &lt;= high &amp;&amp; nums[low] &lt; k) low++; if(high &gt;= 0 &amp;&amp; low &lt; high)&#123; swap(nums, low, high); &#125; &#125; return high + 1;&#125;public void swap(int[] nums, int i, int j) &#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 习题地址Partition Array]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统常用命令]]></title>
    <url>%2F2016%2F06%2F05%2F2016-06-05-linux-frequently-used-order%2F</url>
    <content type="text"><![CDATA[“Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。” 概述UNIX的两个重要分支：System V和BSD UNIX，Linux属于BSD分支。 Linux版本号的命名规则：Linux的内核版本由3部分组成。版本号的第二位数字，可以确定Linux内核版本的类型，第二位数字是偶数的为稳定版本。 Linux里一切皆文件。 档案与目录管理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent)cd dir 切换目录，如果不加dir会切换到用户根目录touch filename 创建空文件echo content &gt; filename 创建带有内容的文件，如果文件存在，会发生覆盖cat filename 查看文件内容cp source dest 拷贝mv source dest 移动或重命名rm 删除文件 -i 删除前进行确认 -r 递归删除，可删除子目录及文件 -f 强制删除find dir -name exp 在文件系统中搜索某文件，content可以是正则表达式 | xargs grep content 查找内容为content的文件wc 统计文本中行数、字数、字符数 -c 统计文本中byte数量 -l 统计文本中字符行数 -m 统计文本中字符数 -w 统计文本中单词个数grep exp filename 在文本文件中查找某个字符串rmdir dir 删除空目录tree dir 树形结构显示目录，需要安装tree包pwd 显示当前目录ln source dest 创建链接文件more, less 分页显示文本文件内容，more在当前页面显示，less会跳转到另一个页面进行显示head, tail 显示文件头、尾内容 -n count 显示指定行数chmod perm file 更改文件访问权限chown username[:groupname] file 更改文件所有者chgrp groupname file 更改文件所在组du 查看目录或文件大小 -h 带有单位显示目录信息df 查看磁盘使用情况 -h 带有单位显示磁盘信息 系统常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243man order 查看某个命令的帮助文档stat 显示指定文件的详细信息，比ls更详细who 显示在线登陆用户whoami 显示当前操作用户hostname 显示主机名uname 显示系统信息top 动态显示当前耗费资源最多进程信息ps 显示瞬间进程状态 ps -auxifconfig 查看网络情况ping 测试网络连通netstat 显示网络状态信息clear 清屏alias 对命令重命名unalias 删除重命名命令kill -sig PID 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。 -1 HUP (hang up) -2 INT (interrupt) -3 QUIT (quit) -6 ABRT (abort) -9 KILL (non-catchable, non-ignorable kill) -14 ALRM (alarm clock) -15 TERM (software termination signal) 登入与登出（开关机）123456789101112131415telnet ip 远程登录login 本机登录exit 退出登录shutdown 关闭计算机 -r time 在某时间关机重启 -h time 在某时间关闭电源 now 立刻关机reboot 重启 打包压缩相关命令123456789101112131415161718192021compress filename 将文件压缩成.Z格式gzip filename 将文件压缩成.gz格式bzip2 filename 将文件压缩成.bz2格式以上三个命令 -d 将相应的文件解压缩tar dest source 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 例： tar -cvf /local/test.tar /local/test 只打包，不压缩 tar -zcvf /local/test.tar.gz /local/test 打包，并用gzip压缩 tar -jcvf /local/test.tar.bz2 /local/test 打包，并用bzip2压缩 tar -xvf /local/test.tar /local/test 只拆包 tar -zxvf /local/test.tar.gz /local/test 用gzip解压缩，并拆包 tar -jxvf /local/test.tar.bz2 /local/test 用bzip2解压缩，并拆包 后台运行与恢复，时间相关1234567&amp; or [Ctrl]+[z] 将命令置于后台运行fg 将后台执行的命令置于前台date 获取当前系统时间cal [month] year 获取某年（某月）日历 用户及用户组管理12345678910111213141516171819202122232425/etc/passwd 存储用户账号的文件/etc/group 存储组账号的文件useradd username 增加用户，只创建用户名，不创建相应目录adduser username 增加用户，并创建相应目录userdel username 删除用户 -r 删除用户目录groupadd groupname 增加组groupdel groupname 删除组usermod -g 组名 用户名 修改用户所在组，会覆盖当前组usermod -G 组名,组名... 用户名 将用户加入多个组passwd username 给user设置密码/etc/profile 系统环境变量.bashrc or .zshrc 用户环境变量 以上即为日常生活工作中常用到的Linux命令，更加高深的运维命令还需大家自己进行更加深入的了解和学习。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试必会题目（1）—— String]]></title>
    <url>%2F2016%2F05%2F31%2F2016-05-31-interview-algorithm-string%2F</url>
    <content type="text"><![CDATA[“面试技术岗位应该掌握的算法题目–String相关” Two Strings Are Anagrams - easy题目 123456Write a method anagram(s,t) to decide if two strings are anagrams or not.ExampleGiven s = "abcd", t = "dcab", return true.Given s = "ab", t = "ab", return true.Given s = "ab", t = "ac", return false. 代码 12345678910111213141516171819202122232425262728293031Java:public boolean anagram(String s, String t) &#123; // write your code here if (s.length() != t.length()) &#123; return false; &#125; HashMap&lt;Character, Integer&gt; hashMap = new HashMap&lt;&gt;(); // 将第一个字符串的每个字母存入哈希表中，也可以用数组进行处理 for (int i = 0; i &lt; s.length(); i++)&#123; char tmp = s.charAt(i); if (hashMap.containsKey(tmp)) &#123; hashMap.put(tmp, hashMap.get(tmp) 1); &#125; else &#123; hashMap.put(tmp, 1); &#125; &#125; // 查询第二个字符串中的每个字母是否在哈希表中 for (int i = 0; i &lt; t.length(); i++) &#123; char tmp = t.charAt(i); if (!hashMap.containsKey(tmp)) &#123; return false; &#125; else &#123; hashMap.put(tmp, hashMap.get(tmp) - 1); if (hashMap.get(tmp) &lt; 0) &#123; return false; &#125; &#125; &#125; return true;&#125; 习题地址Two Strings Are Anagrams Compare Strings - easy题目 123456Compare two strings A and B, determine whether A contains all of the charactersin B.The characters in string A and B are all Upper Case letters.ExampleFor A = "ABCD", B = "ACD", return true.For A = "ABCD", B = "AABC", return false. 代码 123456789101112131415161718192021Java:public boolean compareStrings(String s, String t) &#123; // write your code here int[] arr = new int[26]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = 0; &#125; for (int i = 0; i &lt; s.length(); i++)&#123; char tmp = s.charAt(i); arr[tmp - 'A'] += 1; &#125; for (int i = 0; i &lt; t.length(); i++) &#123; char tmp = t.charAt(i); arr[tmp - 'A'] -= 1; if (arr[tmp - 'A'] &lt; 0) &#123; return false; &#125; &#125; return true;&#125; 习题地址Compare Strings strStr - easy题目 123456789For a given source string and a target string, you should output the firstindex(from 0) of target string in source string.If target does not exist in source, just return -1.ExampleIf source = "source" and target = "target", return -1.If source = "abcdabcdefg" and target = "bcd", return 1. 代码 12345678910111213141516171819202122232425262728Java:public int strStr(String text, String pattern) &#123; //write your code here int result = 0; if (pattern == null || text == null) return -1; if (pattern.equals("")) return 0; int tlen = text.length(), plen = pattern.length(); if (plen &gt; tlen) return -1; int i = 0, j = 0, k; int index; while (i &lt; tlen &amp;&amp; j &lt; plen) &#123; if (text.charAt(i) == pattern.charAt(j)) &#123; i++; j++; continue; &#125; index = result plen; if (index &gt;= tlen) return -1; for (k = plen - 1; k &gt;= 0 &amp;&amp; text.charAt(index) != pattern.charAt(k); k--); i = result; i += plen - k; result = i; j = 0; if (result plen &gt; tlen) return -1; &#125; return i &lt;= tlen? result: -1;&#125; 习题地址strStr Anagrams - medium题目 123456Given an array of strings, return all groups of strings that are anagrams.ExampleGiven ["lint", "intl", "inlt", "code"], return ["lint", "inlt", "intl"].Given ["ab", "ba", "cd", "dc", "e"], return ["ab", "ba", "cd", "dc"]. 代码 12345678910111213141516171819202122232425262728Java:public List&lt;String&gt; anagrams(String[] strs) &#123; int length = strs.length; List&lt;String&gt; result = new ArrayList&lt;&gt;(); if (length == 0 || strs == null) return result; HashMap&lt;String, ArrayList&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String str: strs) &#123; String key = getKey(str); if (!map.containsKey(key)) &#123; map.put(key, new ArrayList&lt;String&gt;()); &#125; map.get(key).add(str); &#125; for (ArrayList&lt;String&gt; tmp: map.values()) &#123; if (tmp.size() &gt; 1) &#123; result.addAll(tmp); &#125; &#125; return result;&#125;public String getKey(String str) &#123; char[] array = str.toCharArray(); Arrays.sort(array); return String.valueOf(array);&#125; 习题地址Anagrams Longest Common Substring - medium题目 1234Given two strings, find the longest common substring.Return the length of it.ExampleGiven A = "ABCD", B = "CBCE", return 2. 代码 123456789101112131415161718192021Java:public int longestCommonSubstring(String A, String B) &#123; // write your code here int max = 0; int lengthA = A.length(); int lengthB = B.length(); if (lengthA &lt; 0 || lengthB &lt; 0) return 0; int[][] arr = new int[lengthA][lengthB]; for (int i = 0; i &lt; lengthA; i++) &#123; for (int j = 0; j &lt; lengthB; j++) &#123; if (A.charAt(i) == B.charAt(j)) &#123; if (i == 0 || j == 0) arr[i][j] = 1; else arr[i][j] = arr[i -1][j - 1] 1; if (max &lt; arr[i][j]) max = arr[i][j]; &#125; &#125; &#125; return max;&#125; 习题地址Longest Common Substring Longest Common Prefix - medium题目 123456Given k strings, find the longest common prefix (LCP).ExampleFor strings "ABCD", "ABEF" and "ACEF", the LCP is "A"For strings "ABCDEFG", "ABCEFG" and "ABCEFA", the LCP is "ABC" 代码 12345678910111213141516171819Java:public String longestCommonPrefix(String[] strs) &#123; // write your code here if (strs.length &lt; 1) return ""; String prefix = strs[0]; int length = prefix.length(); for (String str: strs) &#123; if(str.equals("")) return ""; if (str.length() &lt; length) &#123; length = str.length(); &#125; while (!str.substring(0, length).equals(prefix)) &#123; length -= 1; prefix = prefix.substring(0, length); &#125; &#125; return prefix;&#125; 习题地址Longest Common Prefix String to Integer II - hard题目 1234567891011Implement function atoi to convert a string to an integer.If no valid conversion could be performed, a zero value is returned.If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.Example"10" =&gt; 10"-1" =&gt; -1"123123123123123" =&gt; 2147483647"1.0" =&gt; 1 代码 1234567891011121314151617181920212223242526Java:public int atoi(String str) &#123; // write your code here str = str.trim(); if (str.length() &gt; 12) str = str.substring(0, 12); if (str == null || str.length() &lt; 1) return 0; char [] arr = str.toCharArray(); int symbol = 0; long result = 0; if (arr[0] == '+') symbol = 1; else if (arr[0] == '-') symbol = -1; else if (arr[0] &lt;= '9' &amp;&amp; arr[0] &gt;= '0') result += (arr[0] - '0'); else return 0; for (int i = 1; i &lt; str.length(); i++) &#123; if (arr[i] &lt;= '9' &amp;&amp; arr[i] &gt;= '0') &#123; result *= 10; result += (arr[i] - '0'); &#125; else break; &#125; if (symbol != 0) result *= symbol; if (result &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; else if (result &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; else return (int)result;&#125; 习题地址String to Integer II]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串匹配Sunday算法]]></title>
    <url>%2F2016%2F05%2F28%2F2016-05-28-string-match-sunday%2F</url>
    <content type="text"><![CDATA[“Sunday算法是Daniel M.Sunday于1990年提出的字符串模式匹配。” Sunday算法简介字符串查找算法中，最著名的两个是KMP算法(Knuth-Morris-Pratt)和BM算法(Boyer-Moore)。两个算法在最坏情况下均具有线性的查找时间。但是在实用上，KMP算法并不比c库函数strstr()快多少，而BM算法则往往比KMP算法快上3－5倍(未经验证)。而Sunday算法比BM还要快，而且更易理解。Sunday算法的核心思想是：在匹配过程中，模式串并不被要求一定要按从左向右进行比较还是从右向左进行比较，它在发现不匹配时，算法能跳过尽可能多的字符以进行下一步的匹配，从而提高了匹配效率。 Sunday算法讲解假设现在有两个字符串 主串为 A = “What a nice algorithm” 模式串为 B = “nice” Sunday算法的大致原理是： 先从左到右逐个字符进行比较，以A和B字符串为例：初始状态i = 0, 指向A的第一个字符，j = 0 指向B的第一个字符，分别为W和n，不匹配，于是要把子串往后移动。 W h a t a n i c e a l g o r i t h m i m n i c e j 此时，Sunday算法要求，找到位于A字串中位于B字符串后面的第一个字符，即下图中m所指向的字符空格，在模式字符串B中从后向前查找是否存在空格，如果不存在，则直接将模式串置于m之后。 W h a t a n i c e a l g o r i t h m i m n i c e j 然后将i和j置于新位置，继续进行匹配。 W h a t a n i c e a l g o r i t h m i m n i c e j k a和n不匹配，需要将子串向后移动，可以看到此时m所在位置的字符c和k所在位置的字符c相同，此时需要将相同的字符对齐，让j再次指向B字符串的头一个字符，相应地，将i指向主串对应的字符n。 W h a t a n i c e a l g o r i t h m i n i c e j 此时找到匹配的字符串，算法结束。 Sunday算法代码java代码如下： 12345678910111213141516171819202122232425public int strStr(String text, String pattern) &#123; int result = 0; if (pattern == null || text == null) return -1; if (pattern.equals("")) return 0; // 如果模式串为空，认为第0位已经匹配 int tlen = text.length(), plen = pattern.length(); if (plen &gt; tlen) return -1; int i = 0, j = 0, k; // 分别记录text索引，pattern索引和模式串计数索引 int index; // 记录不匹配时字符（m所在位置）的索引 while (i &lt; tlen &amp;&amp; j &lt; plen) &#123; if (text.charAt(i) == pattern.charAt(j)) &#123; i++; j++; continue; &#125; index = result + plen; if (index &gt;= tlen) return -1; for (k = plen - 1; k &gt;= 0 &amp;&amp; text.charAt(index) != pattern.charAt(k); k--); i = result; i += plen - k; result = i; j = 0; if (result + plen &gt; tlen) return -1; // 如果匹配长度超过主串，匹配失败 &#125; return i &lt;= tlen? result: -1;&#125; 需要注意的测试用例 “”, “” null, “a” “tartarget”, “target” “source”, “rced” 相关题目地址Leetcode:Implement strStr() Lintcode:strStr]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用IDEA和gradle搭建Spring MVC和MyBatis开发环境]]></title>
    <url>%2F2016%2F04%2F12%2F2016-04-12-idea-gradle-ssm%2F</url>
    <content type="text"><![CDATA[“IDEA是jetbrains公司开发的Java开发IDE，功能齐全。使用IDEA搭建SSM开发环境简单有效。” 概述Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。 MyBatis本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 准备工作1.安装mysql，并完成相应数据库的建立 2.安装IDEA完整版 3.下载tomcat或其他服务器 创建工程打开IDEA软件，选择Create New Project： 选择创建基于gradle的java web项目： 输入GroupId和ArtifactId： 选择gradle的来源，可以用自己下载的gradle，也可以使用IDEA内建的gradle版本： 选择项目的目录： 点击完成，会生成一个最基本的java web目录，增加文件夹和相应文件，将其目录结构改为以下结构： 其中resources目录中的config文件夹中的文件和WEB-INF文件夹下的web.xml，以及build.gradle都是自己进行配置的。 配置文件generatorConfig.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;classPathEntry location="$&#123;jarDirection&#125;"/&gt; &lt;context id="mysql" targetRuntime="MyBatis3"&gt; &lt;jdbcConnection driverClass="$&#123;driverClass&#125;" connectionURL="$&#123;connectionURL&#125;" userId="$&#123;userId&#125;" password="$&#123;password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;javaModelGenerator targetPackage="$&#123;modelPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="$&#123;sqlMapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="$&#123;mapperPackage&#125;" targetProject="$&#123;src_main_java&#125;"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 每一个数据库表都需要建立一个对应的table字段 --&gt; &lt;table schema="test" tableName="user" domainObjectName="User" &gt; &lt;!-- &lt;property name="useActualColumnNames" value="true"/&gt; &lt;generatedKey column="ID" sqlStatement="DB2" identity="true" /&gt; &lt;columnOverride column="DATE_FIELD" property="startDate" /&gt; &lt;ignoreColumn column="FRED" /&gt; &lt;columnOverride column="LONG_VARCHAR_FIELD" jdbcType="VARCHAR" /&gt; --&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; gradle.properties123456# 生成的model类所在包modelPackage=cn.edu.bupt.wen.model# 生成的mapper接口类所在包mapperPackage=cn.edu.bupt.wen.mapper# 生成的mapper xml文件所在包sqlMapperPackage=cn.edu.bupt.wen.mybatis_mapper jdbc-mysql.properties123456789# 将jdbc.jarDirection后的内容更改为gradle下载的# mysql-connector-java-5.1.x.jar所在的路径，gradle自动下载的路径如下所示jdbc.jarDirection=/Users/wenzhiquan/.gradle/caches/modules-2/files-2.1/mysql/mysql-connector-java/5.1.38/dbbd7cd309ce167ec8367de4e41c63c2c8593cc5/mysql-connector-java-5.1.38.jarjdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/bookbestjdbc.user=rootjdbc.pass=root spring-mvc.xml12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;!-- 自动扫描控制器 --&gt; &lt;context:component-scan base-package="cn.edu.bupt.wen"/&gt; &lt;!-- 视图渲染 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 控制器映射器和控制器适配器 --&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 静态资源映射器 --&gt; &lt;mvc:resources mapping="/statics/**" location="/WEB-INF/statics/" /&gt;&lt;/beans&gt; web.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" version="3.0"&gt; &lt;servlet&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:config/spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;index-dispather&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; build.gradle12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697group 'cn.edu.bupt.wen'version '1.0-SNAPSHOT'apply plugin: 'groovy'apply plugin: 'java'apply plugin: 'war'apply plugin: 'idea'sourceCompatibility = 1.5repositories &#123; mavenCentral()&#125;configurations &#123; mybatisGenerator&#125;// 读取config文件夹中对应的配置文件ext&#123; def prop = new Properties(); file("src/main/resources/config/mybatis/jdbc-mysql.properties") .withInputStream &#123; prop.load(it) &#125; file("src/main/resources/config/mybatis/gradle.properties") .withInputStream &#123; prop.load(it) &#125; prop.each &#123; project.extensions.add("$it.key",it.value); &#125;&#125;// 配置gradle的依赖项dependencies &#123; compile 'org.codehaus.groovy:groovy-all:2.3.11' compile 'jstl:jstl:1.2' compile 'org.springframework:spring-aop:4.2.4.RELEASE' compile 'org.springframework:spring-context:4.2.4.RELEASE' compile 'org.springframework:spring-beans:4.2.4.RELEASE' compile 'org.springframework:spring-web:4.2.4.RELEASE' compile 'org.springframework:spring-webmvc:4.2.4.RELEASE' compile 'org.springframework:spring-tx:4.2.4.RELEASE' compile 'org.springframework:spring-jdbc:4.2.4.RELEASE' compile 'org.springframework:spring-test:4.2.4.RELEASE' compile 'mysql:mysql-connector-java:5.1.38' compile 'org.mybatis.generator:mybatis-generator-core:1.3.2' compile 'org.mybatis:mybatis-spring:1.2.3' compile 'org.mybatis:mybatis:3.3.0' compile 'junit:junit:4.12' mybatisGenerator 'org.mybatis.generator:mybatis-generator-core:1.3.2' mybatisGenerator 'mysql:mysql-connector-java:5.1.38' testCompile group: 'junit', name: 'junit', version: '4.11'&#125;// 利用ant创建一个自动生成MyBatis目录文件的tasktask mybatisGenerate &lt;&lt; &#123; ant.properties['targetProject'] = projectDir.path ant.properties['jarDirection'] = project['jdbc.jarDirection'] ant.properties['driverClass'] = project['jdbc.driverClassName'] ant.properties['connectionURL'] = project['jdbc.url'] ant.properties['userId'] = project['jdbc.user'] ant.properties['password'] = project['jdbc.pass'] ant.properties['src_main_java'] = sourceSets.main.java.srcDirs[0].path ant.properties['src_main_resources'] = sourceSets.main.resources.srcDirs[0].path ant.properties['modelPackage'] = project['modelPackage'] ant.properties['mapperPackage'] = project['mapperPackage'] ant.properties['sqlMapperPackage'] = project['sqlMapperPackage'] ant.taskdef( name: 'mbgenerator', classname: 'org.mybatis.generator.ant.GeneratorAntTask', classpath: configurations.mybatisGenerator.asPath ) ant.mbgenerator(overwrite: true, configfile: 'src/main/resources/config/mybatis/generatorConfig.xml', verbose: true) &#123; propertyset &#123; propertyref(name: 'targetProject') propertyref(name: 'jarDirection') propertyref(name: 'userId') propertyref(name: 'driverClass') propertyref(name: 'connectionURL') propertyref(name: 'password') propertyref(name: 'src_main_java') propertyref(name: 'src_main_resources') propertyref(name: 'modelPackage') propertyref(name: 'mapperPackage') propertyref(name: 'sqlMapperPackage') &#125; &#125;&#125; 下载gradle依赖包至此，基本的配置就完成了，接下来就需要运行gradle下载相应的依赖包了，操作如下：打开IDEA &gt; View &gt; Tool Windows &gt; gradle: 点击图中的按钮，IDEA就会自动下载依赖包了。 下载完成后，目录下的External Libraries文件夹会生成相应的目录： 下载完依赖包之后，整体的配置基本上就完成了。 部署到Tomcat服务器打开IDEA &gt; Run &gt; Edit Configurations... 点击tomcat server的local选项，点击右上角的configure...，在弹出的对话框中选中下载的Tomcat根目录： 然后将配置好的tomcat添加到运行库当中： 编写代码并运行编写controller代码在controller文件夹中创建IndexController文件，将代码修改为： 12345678910111213141516171819package cn.edu.bupt.wen.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;/** * Author wenzhiquan * Created on 16/4/12 下午12:25 * File name: IndexController.java * Description: null */@Controllerpublic class IndexController &#123; @RequestMapping("/") public String index()&#123; return "index"; &#125;&#125; 修改index.jsp将index.jsp文件修改为自己想要的样式： 12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: wenzhiquan Date: 16/4/12 Time: 下午12:23 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Index&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt;&lt;/html&gt; 运行Tomcat 点击运行按钮，服务器启动后会自动启动浏览器进入主界面： 至此，hello world程序已经完成。 自动生成mybatis相关文件进入gradle的view，点击创建gradle任务： 创建一个mybatisGenerate任务： 点击OK，会在model，mapper和mybatis_mapper文件夹中自动生成相应的文件： 至此，Spring MVC + MyBatis的Java Web开发环境配置完成。]]></content>
      <categories>
        <category>Java</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MyBatis</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[七种基本排序算法]]></title>
    <url>%2F2016%2F03%2F28%2F2016-03-28-seven-sort%2F</url>
    <content type="text"><![CDATA[“排序算法可以说是数据结构与算法当中最为基础的部分” 概述排序算法可以说是数据结构与算法当中最为基础的部分，针对的是数组这一数据结构。将数组中的无序数据元素通过算法整理为有序的数据元素即为排序。 简单排序冒泡排序简介： 冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地访问要排序的数列，将每次访问的最大值“浮”到数组尾部。 步骤如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个，直到把最大的元素放到数组尾部。 遍历长度减一，对剩下的元素从头重复以上的步骤。 直到没有任何一对数字需要比较时完成。 实现代码： 12345def bubbleSort(arr): for i in range(len(arr))[::-1]: for j in range(i): if arr[j] &gt; arr[j + 1]: swap(arr[j], arr[j + 1]) 效果图： 选择排序简介： 选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，重复上述过程，直到所有元素均排序完毕。 步骤如下： 遍历数组，找到最小的元素，将其置于数组起始位置。 从上次最小元素存放的后一个元素开始遍历至数组尾，将最小的元素置于开始处。 重复上述过程，直到元素排序完毕。 实现代码： 1234567def selectSort(arr): for i in range(len(arr)): min = i for j in range(i, len(arr)): if arr[j] &lt; arr[min]: min = j swap(arr[i], arr[min]) 效果图： 插入排序简介： 插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置中 重复步骤2 实现代码： 12345678def insertSort(arr): for i in range(len(arr)): tmp = arr[i] pre = i - 1 while pre &gt;= 0 and arr[pre] &gt; tmp: arr[pre + 1] = arr[pre] pre -= 1 arr[pre + 1] = tmp 高级排序希尔排序简介： 希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。 步骤如下： 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序； 随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 实现代码： 1234567891011121314def insertSort(arr): k = 1 while k &lt; len(arr) / 3: k = 3 * h + 1 //此处为Knuth算法 while k &gt; 0: for i in range(k, len(arr)): tmp = arr[i] pre = i - k while pre &gt;= 0 and arr[pre] &gt; tmp: arr[pre + k] = arr[pre] pre -= k arr[pre + k] = tmp k = (k - 1) / 3 效果图： 快速排序简介： 快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 步骤如下： 步骤： 从数列中挑出一个元素，称为 “基准”（pivot）， 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。 实现代码： 1234567891011121314151617def quickSort(arr, low, high): if low &lt; high: pivot = partition(arr, low, high) quickSort(arr, low, pivot - 1) quickSort(arr, pivot + 1, high)def partition(arr, low, high): pivot = arr[low] while low &lt; high: while low &lt; high and arr[high] &gt;= pivot: high -= 1 arr[low] = arr[high] while low &lt; high and arr[low] &lt;= pivot: low += 1 arr[high] = arr[low] arr[low] = pivot return low 效果图： 归并排序简介： 归并排序(Merge Sort)是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 步骤如下： 申请空间，创建两个数组，长度分别为两个有序数组的长度 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针达到序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 实现代码： 123456789101112131415161718192021222324252627def mergeSort(arr, low, high): if low &lt; high: mid = low + (high - low) / 2 mergeSort(arr, low, mid) mergeSort(arr, mid + 1, high) return merge(arr, low, mid, high)def merge(arr, low, mid, high): leftArr = arr[low : mid + 1] rightArr = arr[mid + 1 : high + 1] i, j, m = 0, 0, low while i &lt; len(leftArr) and j &lt; len(rightArr)： if leftArr[i] &lt; rightArr[j]: arr[m] = leftArr[i] i += 1 else: arr[m] = rightArr[j] j += 1 m += 1 while i &lt; len(leftArr): arr[m] = leftArr[i] m += 1 i += 1 while j &lt; len(rightArr): arr[m] = rightArr[j] m += 1 j += 1 实现效果： 堆排序简介： 堆积排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤如下： 按堆的定义将数组R[0..n]调整为堆（这个过程称为创建初始堆），交换R[0]和R[n]； 将R[0..n-1]调整为堆，交换R[0]和R[n-1]； 重复上述过程，直到交换了R[0]和R[1]为止。 实现代码： 1234567891011121314151617181920def heapSort(arr): for i in range(len(arr) / 2)[::-1]: heapAdjust(arr, i, len(arr)) for i in range(len(arr) - 1)[::-1]: swap(arr[i], arr[0]) heapAdjust(arr, 0, i)def heapAdjust(arr, parent, length)： tmp = arr[parent] child = 2 * parent + 1 while child &lt; length: if child + 1 &lt; length and arr[child + 1] &gt; arr[child]: child += 1 if arr[child] &lt;= tmp: break arr[parent] = arr[child] parent = child child = 2 * parent + 1 arr[parent] = tmp 效果图： 各排序算法时间空间复杂度]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式的八种写法]]></title>
    <url>%2F2016%2F03%2F28%2F2016-03-28-singleton-eight-type%2F</url>
    <content type="text"><![CDATA[“单例模式是最常用到的设计模式之一，熟悉设计模式的朋友对单例模式都不会陌生。” 概述单例模式（singleton）是一种常用的设计模式，其定义是单例对象的类只能允许创建一个实例，而可以被多次调用。 单例模式是设计模式中最简单的形式之一。这一模式的目的是使得类的一个对象成为系统中的唯一实例。要实现这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。使用工厂方法来限制实例化过程。这个方法应该是静态方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。 基本思路显然单例模式的要点有三个： 一是某个类只能有一个实例； 二是它必须自行创建这个实例； 三是它必须自行向整个系统提供这个实例。 单例的实现主要是通过以下两个步骤： 1). 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例； 2). 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 注意事项单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，没有对创建实例的方法进行线程保护，会出现两个线程同时调用创建方法的情况，由于它们没有检测到实例的存在，从而同时各自创建了一个实例，这样就会构造出两个不同的实例，从而违反了单例模式中实例唯一的原则。所以需要对多线程状态下的单例模式进行线程保护。 八种写法懒汉式（线程不安全）[不可用]12345678910111213public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 这种写法起到了Lazy Loading的效果，即只有在需要调用类时才生成相应的实例。 这种写法只能在单线程下使用。如果在多线程下，一个线程进入了if(singleton == null)判断语句块，还未往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。 懒汉式（线程安全，同步方法）[不推荐用]12345678910111213public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 解决了4.1的线程不安全问题，保证了同时只能有一个对getInstance()方法的调用。 缺点：效率低下，每个线程在执行getInstance()方法时都要进行同步。而事实上只要保证第一次建立实例时同步即可。 懒汉式(线程安全，同步代码块)[不可用]123456789101112131415public class Singleton &#123; private static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 由于4.2实现方式同步效率太低，所以摒弃同步方法，改为同步产生实例化的的代码块。 但是这种同步并不能起到线程同步的作用。会遇到与4.1中的实现方式相同的问题，假如一个线程进入了if (singleton == null)判断语句块，还未往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。 双重校验锁[可用]1234567891011121314151617public class Singleton &#123; private static volatile Singleton singleton; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 这种方法是针对4.2实现方式进行的改进，同时又避免了4.3中不能起到线程同步作用的问题。因为在同步代码块中再次进行了if (singleton == null)判断，保证了只会新建一个实例。 注意：因为使用了volatile关键字，所以在JDK1.5之后，双重检查锁定才能够正常达到单例效果。 饿汉式（静态常量）[可用]12345678910public class Singleton &#123; private final static Singleton INSTANCE = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125; 优点：写法简单，在类装载时完成实例化。避免了线程同步问题。 缺点：一定会实例化类，没有达到Lazy Loading的效果。如果从未使用过这个实例，会造成内存的浪费。 饿汉式（静态代码块）[可用]1234567891011121314public class Singleton &#123; private static Singleton instance; static &#123; instance = new Singleton(); &#125; private Singleton() &#123;&#125; public Singleton getInstance() &#123; return instance; &#125;&#125; 和4.5方法起到相同的作用，优缺点也相同。 静态内部类[推荐用]123456789101112public class Singleton &#123; private Singleton() &#123;&#125; private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 这种方式与4.5和4.6的饿汉式写法采用的机制类似，但又不相同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有起到Lazy Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在调用getInstance()方法时，才会装载SingletonInstance类，进而完成Singleton的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：线程安全，延迟加载，效率高。 枚举[推荐用]12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 这种方式是Effective Java作者Josh Bloch提倡的方式，借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒。 适用场合 需要频繁的进行创建和销毁的对象； 创建对象时耗时过多或耗费资源过多，但又经常用到的对象； 工具类对象； 频繁访问数据库或文件的对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>创建型模式</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fedora 22上安装jekyll]]></title>
    <url>%2F2015%2F09%2F18%2F2015-09-18-install-jekyll-fedora%2F</url>
    <content type="text"><![CDATA[“jekyll 是一款简单的博客系统，静态网站生成器。” 概述jekyll是一个简单的免费的Blog生成工具，类似WordPress。但是和WordPress又有很大的不同，原因是jekyll只是一个生成静态网页的工具，不需要数据库支持。但是可以配合第三方服务,例如Disqus。最关键的是jekyll可以免费部署在Github上，而且可以绑定自己的域名。 安装最新版ruby调用命令 1sudo dnf install ruby 安装完成后,输入命令 1ruby -v 会有如下类似的显示: 1ruby 2.2.3p173 (2015-08-18 revision 51636) [x86_64-linux] 说明已经成功安装了2.2.3版本的ruby。 安装jkeyll安装最新版本的jekyll，命令如下： 1gem install jekyll 安装过程中可能会报如下错误: 123456789101112Fetching: ffi-1.9.10.gem (100%)Building native extensions. This could take a while...ERROR: Error installing jekyll: ERROR: Failed to build gem native extension. /usr/bin/ruby -r ./siteconf20150918-17908-j7rbks.rb extconf.rbmkmf.rb can't find header files for ruby at /usr/share/include/ruby.hextconf failed, exit code 1Gem files will remain installed in /home/wenzhiquan/.gem/ruby/gems/ffi-1.9.10 for inspection.Results logged to /home/wenzhiquan/.gem/ruby/extensions/x86_64-linux/ffi-1.9.10/gem_make.out 原因是没有安装gem本地扩展,输入命令sudo dnf install ruby-devel安装dev版本的ruby即可解决问题。如果是报gcc相关的错误,只需要sudo dnf install gcc进行安装即可。 因为我们将会使用Markdown语言作为标记语言，所以还需要安装kramdown，命令如下： 1gem install kramdown 至此，本机的jekyll运行环境就已经搭建好了。 如果ruby下载过慢，可以修改gem的下载源： 1234567gem sources --remove https://rubygems.org/ gem sources -a https://ruby.taobao.org/ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org gem install jekyll 运行例子安装好之后，就可以自己构建一个博客系统，或者也可以到jekyll模板网站 下载自己喜欢的模板进行修改，然后运行并查看效果，要运行jekyll首先要进入博客的根目录，然后运行命令jekyll server，最后会显示启动信息： 12Server address: http://127.0.0.1:4000/Server running... press ctrl-c to stop. 说明程序已经成功启动，在浏览器中输入localhost:4000，就可以查看自己的博客了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS上搭建Nginx,Mysql,PHP开发环境]]></title>
    <url>%2F2015%2F05%2F29%2F2015-05-29-install-nginx-php-mysql-mac%2F</url>
    <content type="text"><![CDATA[“LNMP开发环境是PHP语言开发网站的主流环境。” 概述LNMP代表的就是：Linux系统下Nginx+MySQL+PHP这种网站服务器架构。Linux是一类Unix计算机操作系统的统称，是目前最流行的免费操作系统。代表版本有：debian、centos、ubuntu、fedora、gentoo等。Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。Mysql是一个小型关系型数据库管理系统。PHP是一种在服务器端执行的嵌入HTML文档的脚本语言。这四种软件均为免费开源软件，组合到一起，成为一个免费、高效、扩展性强的网站服务系统。 安装Homebrew使用Mac的程序员必不可少的一步便是安装Homebrew，他就像是centOS的yum命令和ubuntu的apt-get命令一样，通过brew命令，我们可以快速的安装一些软件包。使用命令行安装Homebrew的命令如下： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 使用brew doctor检查是否存在冲突，然后使用brew update &amp;&amp; brew upgrade对brew进行升级。 安装nginxnginx在Mac OS中可以直接使用brew命令进行安装： 1brew install nginx 如果需要使用80端口的话，需要将nginx加入root组当中： 12sudo cp -v /usr/local/opt/nginx/*.plist /Library/LaunchDaemons/sudo chown root:wheel /Library/LaunchDaemons/homebrew.mxcl.nginx.plist 然后使用命令启动nginx服务： 1sudo nginx 测试nginx是否安装成功，因为默认配置文件监听的是8080端口，所以先对8080端口发起请求： 1curl -IL http://127.0.0.1:8080 结果应该类似于下： 123456789HTTP/1.1 200 OKServer: nginx/1.9.1Date: Fri, 29 May 2015 14:50:47 GMTContent-Type: text/htmlContent-Length: 612Last-Modified: Fri, 29 May 2015 14:40:47 GMTConnection: keep-aliveETag: "5444dea7-264"Accept-Ranges: bytes nginx的相关操作如下： 12sudo nginx //启动nginxsudo nginx -s reload|reopen|quit //重新加载|重启|退出 安装php-fpm因为brew并没有php-fpm的源，所以首先要添加源： 12brew tap homebrew/dupesbrew tap homebrew/php 然后安装php-fpm，输入命令: 1brew install php56 --whitout-apache --with-imap --with-tidy --with-debug --with-pgsql --with-mysql --with-fpm 程序会自动安装，等待几分钟后完成安装。 安装完成后，还需要将php加入$PATH当中： 123456789# 如果使用bash的话vim ~/.bash_profileexport PATH="/usr/local/sbin:$PATH"source ~/.bash_profile# 如果使用ZSH的话vim ~/.zshrcexport PATH="/usr/local/sbin:$PATH"source ~/.zshrc 然后可以设置php-fpm的开机自启动： 123mkdir -p ~/Library/LaunchAgentsln -sfv /usr/local/opt/php56/homebrew.mxcl.php56.plist ~/Library/LaunchAgents/launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.php56.plist 使用以下命令监测php-fpm是否启动成功： 1lsof -Pni4 | grep LISTEN | grep php 如果启动成功应当有以下类似输出： 1234php-fpm 27578 wenzhiquan 9u IPv4 0xf29f8b26c08fc27 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 27628 wenzhiquan 0u IPv4 0xf29f8b26c08fc27 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 27629 wenzhiquan 0u IPv4 0xf29f8b26c08fc27 0t0 TCP 127.0.0.1:9000 (LISTEN)php-fpm 27630 wenzhiquan 0u IPv4 0xf29f8b26c08fc27 0t0 TCP 127.0.0.1:9000 (LISTEN) 安装MySQLMySQL也可以使用brew命令直接进行安装： 1brew install mysql 同样，可以设置MySQL的开机自启动： 12ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgentslaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 然后进行MySQL的安全安装，使用以下命令，可以更改root密码、删除匿名用户、关闭远程连接等： 1mysql_secure_installation 然后会输出以下内容： 123456&gt; Enter current password for root (enter for none): //默认没有密码，直接回车即可&gt; Change the root password? [Y/n] //是否更改root密码，选择是，然后输入并确认密码&gt; Remove anonymous users? [Y/n] //是否删除匿名用户，选择是&gt; Disallow root login remotely? [Y/n] //是否禁止远程登录，选择是&gt; Remove test database and access to it? [Y/n] //是否删除test数据库，选择是&gt; Reload privilege tables now? [Y/n] //是否重载表格数据，选择是 测试数据库是否安装成功： 1mysql -u root -p 然后输入刚才设置的root密码，将会输出以下内容： 123Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; exit //输入exit退出数据库 配置nginx首先，为我们的配置文件创建一些文件夹，这些是仿照ubuntu的nginx结构进行建立的目录： 123456789mkdir -p /usr/local/etc/nginx/logsmkdir -p /usr/local/etc/nginx/sites-availablemkdir -p /usr/local/etc/nginx/sites-enabledmkdir -p /usr/local/etc/nginx/conf.dmkdir -p /usr/local/etc/nginx/sslsudo mkdir -p /var/wwwsudo chown :staff /var/wwwsudo chmod 775 /var/www 然后修改nginx配置文件： 1vim /usr/local/etc/nginx/nginx.conf 将内容替换为： 1234567891011121314151617181920212223242526worker_processes 1;error_log /usr/local/etc/nginx/logs/error.log debug;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /usr/local/etc/nginx/logs/access.log main; sendfile on; keepalive_timeout 65; index index.html index.php; include /usr/local/etc/nginx/sites-enabled/*;&#125; 然后创建php-fpm配置文件： 1vim /usr/local/ect/nginx/conf.d/php-fpm 输入以下内容： 1234567location ~ \.php$ &#123; try_files $uri = 404; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 然后加入站点配置文件： 1vim /usr/local/ect/nginx/sites-enabled/default 输入以下内容： 1234567891011121314151617181920server &#123; listen 80; server_name localhost; root /var/www/; access_log /usr/local/etc/nginx/logs/default.access.log main; location / &#123; include /usr/local/etc/nginx/conf.d/php-fpm; &#125; location = /info &#123; allow 127.0.0.1; deny all; rewrite (.*) /.info.php; &#125; error_page 404 /404.html; error_page 403 /403.html;&#125; 重启nginx，至此，配置完成，在www下写一个测试文件，进行测试即可 尽情的享受在Mac OS开发PHP的快感吧！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Nginx</tag>
        <tag>Mysql</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS Yosemite 配置sublime text C语言开发环境]]></title>
    <url>%2F2015%2F05%2F04%2F2015-05-04-mac-sublime-c%2F</url>
    <content type="text"><![CDATA[“Sublime Text是一个轻便的文本编辑器” 概述Sublime Text 是一个代码编辑器，也是HTML和散文先进的文本编辑器。它是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，代码段等。还可自定义键绑定，菜单和工具栏。它的主要功能包括：拼写检查，书签，Goto 功能，即时项目切换，多选择，多窗口等等。它是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。它还具有大量的可扩展插件，极大地丰富了这款编辑器的功能。 安装配置sublime text安装sublime text 3首先可以前往Sublime Text官方网站下载对应平台的软件，安装完成后即可使用。但是为了更好地使用这一款强大的软件，我们可以安装一些插件。 这款软件是永久免费的，但是免费版会时不时的弹出购买提示，下面提供一个注册码，可以直接注册这个软件： 12345678910111213—– BEGIN LICENSE —–Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523—— END LICENSE —— 安装sublime text 3 插件Package Control组件： 按control+`(键盘上1左边的按钮)调出console控制台 粘贴以下代码到底部命令行并回车： 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启Sublime Text 3 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功 下面是sublime text 2 的安装命令： 1import urllib2,os; pf='Package Control.sublime-package'; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), 'wb' ).write( urllib2.urlopen( 'http://sublime.wbond.net/' +pf.replace( ' ','%20' )).read()); print( 'Please restart Sublime Text to finish installation') 用Package Control安装插件的方法： 按下Ctrl+Shift+P调出命令面板 输入pcic 调出 Install Package 选项并回车，然后在列表中选中要安装的插件 较为常用的一些插件 ConvertToUTF8 支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件 Bracket Highlighter 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效 DocBlockr DocBlockr可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++ Emmet(Zen Coding) 快速生成HTML代码段的插件，强大到无与伦比，不知道的请自行google SideBar Enhancements 这个插件改进了侧边栏，增加了许多功能 SideBar Folders 增加了侧边栏对于文件夹的支持 SublimeCodeIntel 提供了代码提示和自动补全功能 sublime text 还具有很多插件，读者可以根据自己所使用的语言和需要进行相应的安装 配置sublime text主题 Sublime Text本身对于主题的扩展也是十分的强大，一些推荐的主题可以前往design beep网站进行选择和安装 下面介绍一下我安装的主题和相应的配置文件： 在package control中分别输入numix和itg.flat进行主题的安装，然后安装插件markdown extend增加对markdown语法的支持，然后编辑Settings-User，加入以下内容： 123456&#123; "color_scheme": "Packages/Theme - itg.flat/itg.dark.tmTheme", "numix_sidebar_tree_medium": true, "numix_small_tabs": true, "theme": "Numix.sublime-theme"&#125; 效果如下： 安装gcc安装完sublime text后，编辑C语言的文本编辑器就已经配置好了，但是想要编译C文件，则需要安装gcc，在Mac OS中，直接使用brew命令进行安装即可，安装命令如下： 1brew install gcc 等待安装完成 输入命令gcc -v验证是否安装成功，如果安装成功，应该有以下提示： 1234Configured with: --prefix=/Library/Developer/CommandLineTools/usr --with-gxx-include-dir=/usr/include/c++/4.2.1Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)Target: x86_64-apple-darwin14.3.0Thread model: posix 配置sublime text的C语言编译系统经过前面的步骤，就可以分别进行C语言的编辑和编译，但是为了方便，只需要简单地配置就可以直接用sublime text进行编译了 打开Tools-&gt;Build System-&gt;New Build System，在新建的文件中输入以下内容： 123456789101112&#123; "cmd" : ["gcc -o $&#123;file_base_name&#125; $file_name"], "shell" : true, "working_dir" : "$file_path", "selector": "source.c", "encoding":"utf-8", "variants" : [&#123; "name" : "Run", "cmd" : "./$&#123;file_base_name&#125;" &#125;]&#125; 使用control+B进行编译文件，使用control+shift+B运行编译好的文件 以下是sublime text 2的内容 1234567&#123; "cmd" : ["gcc", "-o", "$file_base_name", "$file_name"], "cmd" : ["./$file_base_name"], "selector" : "source.c", "shell" : true, "working_dir" : "$file_path"&#125; 第一行相当于在shell中输入命令gcc -o 文件名 文件名.c 第二行则是运行编译成功的文件 第三行的意思是对后缀为.c的文件进行选择 编辑完成后，保存文件，命名为C.sublime-build，然后就可以在Build System中选中这个编译方式了 编辑文件hello.c: 123456#include &lt;stdio.h&gt;int main()&#123; printf("hello world\n"); return 0;&#125; 使用命令command + B编译并运行，效果如下: 至此，就可以在你的Mac OS中使用sublime text进行C语言的开发了]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS安装jekyll]]></title>
    <url>%2F2015%2F03%2F19%2F2015-03-19-mac-install-jekyll%2F</url>
    <content type="text"><![CDATA[“jekyll 是一款简单的博客系统，静态网站生成器。” 概述jekyll 是一款简单的博客系统，静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过Liquid处理模版文件，把使用标记语言Textile或Markdown编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过它实现的。搭建好我们的博客系统之后，我们还可以把它放到github的pages上进行展示。 安装Homebrew使用Mac的程序员必不可少的一步便是安装Homebrew，他就像是centOS的yum命令和ubuntu的apt-get命令一样，通过brew命令，我们可以快速的安装一些软件包。使用命令行安装Homebrew的命令如下： 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装最新版rubyHomebrew安装完成之后，使用它来安装最新版本的ruby，代码如下： 1brew install ruby 安装完成之后，会提示安装好的ruby目录为/usr/local/Cellar/ruby/2.2.0,我用的shell为zsh，所以想要最新安装的ruby生效，需要将~/.zshrc配置文件中的环境变量PATH中添加上新版本ruby的目录，在PATH后添加上ruby安装目录的bin文件夹，如下： 1export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/Cellar/ruby/2.2.0/bin" 然后输入命令source ~/.zshrc，再使用ruby就是最新版本了。 输入命令ruby --version查看ruby版本： 1ruby 2.2.0p0 (2014-12-25 revision 49005) [x86_64-darwin14] 如果，版本不对，就使用命令echo $PATH查看最新版本的ruby目录是否在环境变量PATH中，如果不对，就按照上述过程修改环境变量PATH。 安装jkeyll安装最新版本的jekyll，命令如下： 1gem install jekyll 因为我们将会使用Markdown语言作为标记语言，所以还需要安装kramdown，命令如下： 1gem install kramdown 至此，本机的jekyll运行环境就已经搭建好了 运行例子安装好之后，就可以自己构建一个博客系统，或者也可以到jekyll模板网站 下载自己喜欢的模板进行修改，然后运行并查看效果，要运行jekyll首先要进入博客的根目录，然后运行命令jekyll server，最后会显示启动信息： 12Server address: http://127.0.0.1:4000/Server running... press ctrl-c to stop. 说明程序已经成功启动，在浏览器中输入localhost:4000，就可以查看自己的博客了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fedora22 配置Nginx,Mysql,PHP]]></title>
    <url>%2F2014%2F12%2F09%2F2014-12-09-nginx-mysql-php-fedora%2F</url>
    <content type="text"><![CDATA[“LNMP开发环境是PHP语言开发网站的主流环境。” 安装nginxnginx在fedora当中是一个默认包，所以直接使用命令行进行安装即可： 1sudo dnf install nginx -y 然后启动nginx服务： 1sudo service nginx start 当然，也可以设置他为开机启动： 1sudo systemctl enable nginx.service 然后在你的浏览器当中输入localhost，如果看到以下界面即为安装成功： 安装MySQLmysql在fedora当中叫做MariaDB，但是也可以用安装mysql的命令直接进行安装： 1sudo dnf install mysql mysql-server -y 然后启动mysql服务： 1sudo service mariadb start 当然，也可以设置他为开机启动： 1sudo systemctl enable mariadb.service 然后输入命令： 1sudo netstat -tap | grep mysql 如果出现以下代码，说明启动成功： 12tcp 0 0 0.0.0.0:mysql 0.0.0.0:* LISTEN 5464/mysqld 启动成功后，我们需要给root用户设置一个密码，以防止任何人都可以访问我们的数据库： 1mysqladmin -u root password "root" 安装PHP我们可以让PHP5在nginx中以FastCGI的模式工作。 1sudo dnf install php lighttpd-fastcgi php-devel php-fpm php-mysql -y 然后启动php-fpm服务： 1sudo service php-fpm start 当然，也可以设置他为开机启动： 1sudo systemctl enable php-fpm.service 启动之后，还需要配置nginx使之支持php 配置nginx支持php首先备份原先的conf文件 1mv /etc/nginx/nginx.conf /etc/nginx/nginx.conf.bak 然后复制一份配置文件 1cp /etc/nginx/nginx.conf.default /etc/nginx/nginx.conf 新建两个目录用于分别存放可用和生效的配置文件 12mkdir -p /etc/nginx/sites-avaliablemkdir -p /etc/nginx/sites-enabled 这两个目录是模仿Ubuntu的nginx目录进行创建的，其中sites-analiable文件夹用于存放所有可用的server配置，sites-enabled文件夹用于存放生效的server配置 修改nginx配置文件，添加fastcgi支持 1vim /etc/nginx/nginx.conf 将文件修改为以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes 1;error_log /var/log/nginx/error.log;#error_log /var/log/nginx/error.log notice;#error_log /var/log/nginx/error.log info;pid /run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125; 文件将从conf.d和sites-enabled文件夹中读取所有的server配置，首先需要在sites-avaliable文件夹中建立可用的server配置，然后软链接到sites-enabled文件夹中，这样就可以修改可用配置时，生效配置也会修改，但是删除生效配置时不会对可用配置造成影响： 1vim /etc/nginx/sites-avaliable/default 将其修改为以下内容： 1234567891011121314151617181920212223242526272829## The default server#server &#123; listen 80; server_name localhost; # or other domain name you like. #include /data/www/.htaccess; charset utf-8; #access_log logs/host.access.log main; root /usr/share/nginx/html;//这里是web项目文件夹的根目录 include /etc/nginx/default.d/*.conf;//这个配置文件是安装php和php-fpm时自动生成的，是对nginx针对php的配置 location / &#123; #try_files $uri $uri/ /index.php?$args; &#125; error_page 404 /404.html; location = /404.html &#123; &#125; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; 然后在sites-enabled文件夹中建立可用配置的软链接即可1ln -s /etc/nginx/sites-avaliable/default /etc/nginx/sites-enabled/ 具体的其他nginx相关配置可以详见nginx官方网站 另外，如果php报与时区相关的错误，则需要修改/etc/php.ini文件，在其中[Date]标签下加入一行date.timezone = &#39;Asia/Shanghai&#39;即可 测试每次配置nginx文件后，都需要将其进行重启： 1sudo service nginx restart 每次配置php.ini文件后，也需要将其进行重启： 1sudo service php-fpm restart 然后建立index.php文件进行测试： 12345vim /usr/share/nginx/html/info.php&lt;?php phpinfo();?&gt; 然后在浏览器中输入servername进行测试： 12输入：localhost/info.php显示phpinfo界面说明解析成功]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
        <tag>PHP</tag>
        <tag>Nginx</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 简明语法]]></title>
    <url>%2F2014%2F10%2F14%2F2014-10-14-markdown-simple-syntax%2F</url>
    <content type="text"><![CDATA[“Markdown 语言是现在编写博客最为常用的语言。” 简介Markdown 的目标是实现「易读易写」，成为一种适用于网络的「书写语言」。 一份使用 Markdown 格式撰写的文件可以直接以纯文本发布，它的最大灵感来源其实是纯文本电子邮件的格式。 Markdown 的语法由一些符号所组成，其作用一目了然。比如：在文字两旁加上星号，看起来就像强调。 Markdown 兼容 HTML 语法并且会将&lt;和&amp;等符号进行自动转换，这项特性可以让我们很容易地用 Markdown 写 HTML code。 区块元素段落和换行 空白行表示单一段落，相当于&lt;p/&gt;。 连续两个空格表示换行，相当于&lt;br/&gt;。 连续三个*或+或-,然后空白行，表示 hr 横线 标题标题是在首行插入 1 到 6 个#,对应的是标题 1 至标题 6，例如： 1234567# 这是 H1## 这是 H2...###### 这是 H6 同时，也可以选择性地「闭合」标题，在行尾加上#，这么做只是为了美观： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ### 区块引用Markdown 标记区块引用是使用类似 email 中用&gt;加space的引用方式: 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 效果为： This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套，只要根据层次加上不同数量的&gt;： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 效果为： This is the first level of quoting. This is nested blockquote. Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return &quot;Hello world!&quot;; 列表Markdown 支持有序列表和无序列表。 无序列表使用*、+或是-作为列表标记： 12345678910# 三种符号效果相同* Red* Green* Blue+ Red+ Green+ Blue- Red- Green- Blue 效果均为： Red Green Blue 有序列表则使用数字接着一个英文句点.： 1231. Bird2. McHale3. Parish 效果为： Bird McHale Parish 代码区块要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个space或是 1 个tab就可以，例如，下面的输入： 123这是一个普通段落： 这是一个代码区块。 效果为： 这是一个普通段落： 这是一个代码区块。 代码区块中，一般的 Markdown 语法不会被转换，像是*便只是*。 此外，还可以使用一对‘ ``` ‘（连续三个数字键 1 左边的反引号）将段落包围起来使其成为代码区块。 分割线你可以在一行中用三个以上的*、-、_来建立一个分隔线，行内不能有其他东西。你也可以在*或是-中间插入space。下面每种写法都可以建立分隔线： 123456789* * *********- - ---------------------------------------- 表格可以使用以下的方式建立表格： 123456789h1|h2|h3--|--|--c1|c2|c3或者|h1|h2|h3||--|--|--||c1|c2|c3| 效果如下： h1 h2 h3 c1 c2 c3 或者 h1 h2 h3 c1 c2 c3 区段元素链接Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。 不管是哪一种，链接文字都是用[]来标记。 行内式链接 要建立一个行内式的链接，只要在[]后面紧接着()并插入网址链接即可，如果你还想要加上链接的title文字，只要在网址后面，用&quot;&quot;把title文字包起来即可，例如： 123这是[百度](http://www.baidu.com "百度首页")的行内式链接.这个[百度](http://www.baidu.com)不包含`title`参数. 效果为： 这是百度的行内式链接. 这个百度不包含title参数. 参考式链接 参考式的链接是在链接文字的[]后面再接上另一个[]，而在第二个[]里面要填入用以辨识链接的标记，接着，在文件的任意处，你可以把这个标记的链接内容定义出来： 这是[百度][id]参考式链接. [id]: http://www.baidu.com "百度首页" 效果为： 这是百度参考式链接. 链接内容定义的形式为： []（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 紧跟着一个: 接着是一个以上的space或tab 然后是链接的网址 最后可以选择性地输入title内容，可以用&#39;&#39;、&quot;&quot;或是()包着 强调Markdown 使用星号*和下划线_作为标记强调字词的符号，被*或_包围的字词会被转成用&lt;em&gt;标签包围，用两个*或_包起来的话，则会被转成&lt;strong&gt;，例如： 1234567*单个星号*_单个下划线_**双星号**__双下划线__ 效果为： 单个星号 单个下划线 双星号 双下划线 强调样式的限制是，样式符号必须成对出现，如果你的*和_两边都有空白的话，它们就只会被当成普通的符号。 强调也可以直接插在文字中间： 1这是一个*强调*。 效果为： 这是一个强调。 代码如果要标记一小段行内代码，你可以用`把它包起来，例如： 1Use the `printf()` function. 效果为： Use the printf() function. 图片Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。 行内式图片 行内式的图片语法看起来像是： 123![测试图片](/uploads/home-bg-art.jpg)![测试图片](/uploads/home-bg-art.jpg "这是一个测试图片") 详细叙述如下： 一个! 接着一个[]，里面放上图片的替代文字 接着一个()，里面放上图片的网址，最后还可以用&quot;&quot;包住,并加上选择性的title文字。 效果为： 参考式图片 参考式的图片语法则如下： ![Alt text][id] [id]: /uploads/home-bg-art.jpg "这是一个测试图片" 效果为： 到目前为止，Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的&lt;img&gt;标签。 其他自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来，Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 123&lt;http://www.baidu.com&gt;&lt;baidu@163.com&gt; 效果为： http://www.baidu.com mailto:baidu@163.com 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号: 123456789101112\\ 反斜线\` 反引号\* 星号\_ 底线\&#123;&#125; 花括号\[] 方括号\() 括弧\# 井字号\+ 加号\- 减号\. 英文句点\! 惊叹号 效果为： \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>简明语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fedora 20 安装gitolite]]></title>
    <url>%2F2014%2F10%2F14%2F2014-10-14-fedora-20-gitolite%2F</url>
    <content type="text"><![CDATA[“git本地化之后，可能会用到权限管理，gitolite就是一个强大的权限管理工具” gitolite安装先决条件关于git和ssh登录的基础知识，网上已经有很多很好的文章，在这里就不再加以赘述了。 安装git要安装gitolite，首先要安装git: 1sudo yum install git 创建git用户组和git用户然后，需要新建用户和用户组git，以方便所有用户使用git账户进行登录： 12345678# 添加git用户组sudo groupadd git# 创建新用户git并将其添加到用户组git之中sudo adduser -g git git# 修改用户git的密码sudo passwd git 创建管理员密钥由于初始化gitolite需要一个管理员的公钥，所以需要创建一个key: 12345678910111213141516171819202122# 为名为“yourname”的账户生成相应的keyssh-keygen -t rsa -C "yourname"# 选择存储key的位置及key文件名称Enter file in which to save the key (/home/user/.ssh/id_rsa): /home/user/.ssh/yournameEnter passphrase (empty for no passphrase): #为你的key创建密码，一般不需要，回车即可Enter same passphrase again: #回车即可# 最后输出类似的结果表示key生成成功...The key's randomart image is:+--[ RSA 2048]----+| . . || = . || . o E || o o = o || o o = S || . + B. || . =o. || .o. || .oo. |+-----------------+ 将公钥上传到git用户中生成key之后，需要将其上传到git用户之中： 12345# 将公钥上传到git用户中scp /home/user/.ssh/yourname.pub git@localhost:/tmpECDSA key fingerprint is 77:ad:e9:c2:e3:9f:bc:eb:38:42:e8:24:4f:b4:4a:a9.Are you sure you want to continue connecting (yes/no)? yes 若此时出现错误： 12ssh: connect to host 127.0.0.1 port 22: Connection refusedlost connection 则说明ssh服务没有打开，需要开启ssh服务： 12345# 开启ssh服务sudo service sshd start# 开机启动ssh服务sudo systemctl enable sshd.service 除此之外，要让局域网内的用户能够访问git服务器，需要关闭防火墙： 12sudo systemctl stop firewalld.servicesudo systemctl disable firewalld.service 安装gitolite进入git用户并创建bin目录安装gitolite的操作需要在git用户下进行，首先需要切换到git用户： 1su git 输入密码后，需要切换到git用户的用户根目录下创建bin文件夹： 1234cd ~# 创建bin文件夹是为了将gitolite安装到其中便于认知和管理mkdir bin 克隆gitolite并安装我们需要从github中克隆gitolite的官方仓库进行安装： 12345# 克隆gitolite仓库git clone git://github.com/sitaramc/gitolite#将gitolite安装到bin目录下./gitolite/install -to ~/bin/ 安装gitolite的时候，可能会出现错误： 1Can't locate Data/Dumper.pm in @INC 这是由于没有安装相应的perl包所导致的，需要切换回非git用户进行安装，使用命令： 1234# 使用CPAN安装perl包sudo perl -MCPAN -e shellcpan[1]&gt; install Data::Dumper 如果是首次使用CPAN会进行一定的配置，在询问是否自动配置处输入yes即可。 使用CPAN时可能出现错误： 1Can't locate CPAN.pm in @INC 这是由于没有安装CPAN出现的错误，使用命令： 1sudo yum install perl-CPAN 安装完成后，应该会自动集成Data::Dumper包。 回到git用户，安装gitolite后，bin文件夹中会出现相应的文件，到此，gitolite就安装成功了。 使用公钥初始化gitolite完成安装gitolite后，需要使用刚才上传的公钥将gitolite进行初始化，这个公钥的所有者将成为gitolite的第一个管理员, 在git用户根目录下，使用命令： 123456789# 使用yourname.pub对gitolite进行初始化./bin/gitolite setup -pk yourname.pub初始化空的 Git 版本库于 /home/git/repositories/gitolite-admin.git/初始化空的 Git 版本库于 /home/git/repositories/testing.git/WARNING: /home/git/.ssh missing; creating a new one (this is normal on a brand new install)WARNING: /home/git/.ssh/authorized_keys missing; creating a new one (this is normal on a brand new install) 到此为止，gitolite的初始化已经完成。 添加gitolite的用户和仓库不要手动在git服务器中添加新用户或者新仓库。因为gitolite的用户，仓库和权限规则都是使用一个名为gitolite-admin的特殊仓库进行维护的，想要进行修改，就需要通过修改该仓库的文件并push到服务器当中。 要添加用户和仓库，首先需要退出git用户后，将gitolite-admin克隆到本地: 12345# 退出git用户exit# 将gitolite-admin仓库克隆到本地git clone git@localhost:gitolite-admin 进入gtiolite目录后，可以看到两个子目录conf和keydir，conf/gitolite.conf用于修改仓库，用户及其权限，keydir用于存放用户的公钥。 为了增加新用户alice，bob和carol， 首先需要获取他们的公钥（alice.pub，bob.pub和carol.pub），并添加到keydir文件夹当中。 为了增加新仓库foo，并赋予这些用户不同的权限，修改conf/gitolite.conf文件： 1234repo foo RW+ = alice RW = bob R = carol 进行修改之后，需要将改动上传到服务器使其生效： 1234git add confgit add keydirgit commit -m "added foo, gave access to alice, bob, carol"git push 当git的push操作成功后，gitolite将会把新用户添加到服务器的~/.ssh/authorized_keys文件中，然后会新建一个名为foo的空仓库。 进阶操作权限管理gitolite的权限管理非常强大，之前展示的只是最简单的权限管理，下面是更加深入一些的管理： 1234567repo foo RW+ = alice - master = bob - refs/tags/v[0-9] = bob RW = bob RW refs/tags/v[0-9] = carol R = dave 下面对上述规则进行阐述： alice能够对仓库进行所有的操作。 bob能够创建和推送任何名字不为master的分支，并能够添加任何不以v+数字开头的tag。 carol能够添加任何以v+数字开头的tag。 dave能够进行clone和fetch操作。 更加详细的权限管理请看官方文档。 组gitolite允许创建用户组： 123456789@staff = alice bob carol@interns = ashokrepo secret RW = @staffrepo foss RW+ = @staff RW = @interns 用户组是可以堆叠的，下面的写法和上方的@staff是相同的： 12@staff = alice bob@staff = carol 同样的，也可以将用户组添加到另一个用户组当中： 1@all-devs = @staff @interns 此外，gitolite有一个特殊的用户组，名为@all，他表示所有的用户。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
      </tags>
  </entry>
</search>
